\section{High Level D\+ES functions}
\label{group__CRYP__Group8}\index{High Level D\+E\+S functions@{High Level D\+E\+S functions}}


High Level D\+ES functions.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Error\+Status} \textbf{ C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB} (uint8\+\_\+t Mode, uint8\+\_\+t Key[8], uint8\+\_\+t $\ast$Input, uint32\+\_\+t Ilength, uint8\+\_\+t $\ast$Output)
\begin{DoxyCompactList}\small\item\em Encrypt and decrypt using D\+ES in E\+CB Mode. \end{DoxyCompactList}\item 
\textbf{ Error\+Status} \textbf{ C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC} (uint8\+\_\+t Mode, uint8\+\_\+t Key[8], uint8\+\_\+t Init\+Vectors[8], uint8\+\_\+t $\ast$Input, uint32\+\_\+t Ilength, uint8\+\_\+t $\ast$Output)
\begin{DoxyCompactList}\small\item\em Encrypt and decrypt using D\+ES in C\+BC Mode. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
High Level D\+ES functions. 

\begin{DoxyVerb} ===============================================================================
                          High Level DES functions
 ===============================================================================
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\label{group__CRYP__Group8_ga75724391a8560c557e1152b805f5cad1}} 
\index{High Level D\+E\+S functions@{High Level D\+E\+S functions}!C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC@{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC}}
\index{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC@{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC}!High Level D\+E\+S functions@{High Level D\+E\+S functions}}
\subsubsection{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+B\+C()}
{\footnotesize\ttfamily \textbf{ Error\+Status} C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+C\+BC (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{Mode,  }\item[{uint8\+\_\+t}]{Key[8],  }\item[{uint8\+\_\+t}]{Init\+Vectors[8],  }\item[{uint8\+\_\+t $\ast$}]{Input,  }\item[{uint32\+\_\+t}]{Ilength,  }\item[{uint8\+\_\+t $\ast$}]{Output }\end{DoxyParamCaption})}



Encrypt and decrypt using D\+ES in C\+BC Mode. 


\begin{DoxyParams}{Parameters}
{\em Mode} & encryption or decryption Mode. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item M\+O\+D\+E\+\_\+\+E\+N\+C\+R\+Y\+PT\+: Encryption \item M\+O\+D\+E\+\_\+\+D\+E\+C\+R\+Y\+PT\+: Decryption \end{DoxyItemize}
\\
\hline
{\em Key} & Key used for D\+ES algorithm. \\
\hline
{\em Init\+Vectors} & Initialisation Vectors used for D\+ES algorithm. \\
\hline
{\em Ilength} & length of the Input buffer, must be a multiple of 8. \\
\hline
{\em Input} & pointer to the Input buffer. \\
\hline
{\em Output} & pointer to the returned buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em An} & Error\+Status enumeration value\+:
\begin{DoxyItemize}
\item S\+U\+C\+C\+E\+SS\+: Operation done
\item E\+R\+R\+OR\+: Operation failed 
\end{DoxyItemize}\\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 189} of file \textbf{ stm32f4xx\+\_\+cryp\+\_\+des.\+c}.



References \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Algo\+Dir}, \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Algo\+Mode}, \textbf{ C\+R\+Y\+P\+\_\+\+Cmd()}, \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Data\+Type}, \textbf{ C\+R\+Y\+P\+\_\+\+F\+I\+F\+O\+Flush()}, \textbf{ C\+R\+Y\+P\+\_\+\+Init()}, \textbf{ C\+R\+Y\+P\+\_\+\+I\+V\+Init()}, \textbf{ C\+R\+Y\+P\+\_\+\+Key\+Init()}, \textbf{ C\+R\+Y\+P\+\_\+\+Key\+Struct\+Init()}, \textbf{ D\+I\+S\+A\+B\+LE}, \textbf{ E\+N\+A\+B\+LE}, and \textbf{ S\+U\+C\+C\+E\+SS}.


\begin{DoxyCode}
00191 \{
00192   CRYP_InitTypeDef DES\_CRYP\_InitStructure;
00193   CRYP_KeyInitTypeDef DES\_CRYP\_KeyInitStructure;
00194   CRYP_IVInitTypeDef DES\_CRYP\_IVInitStructure;
00195   \_\_IO uint32\_t counter = 0;
00196   uint32\_t busystatus = 0;
00197   ErrorStatus status = SUCCESS;
00198   uint32\_t keyaddr    = (uint32\_t)Key;
00199   uint32\_t inputaddr  = (uint32\_t)Input;
00200   uint32\_t outputaddr = (uint32\_t)Output;
00201   uint32\_t ivaddr     = (uint32\_t)InitVectors;
00202   uint32\_t i = 0;
00203 
00204   \textcolor{comment}{/* Crypto structures initialisation*/}
00205   CRYP_KeyStructInit(&DES\_CRYP\_KeyInitStructure);
00206 
00207   \textcolor{comment}{/* Crypto Init for Encryption process */}
00208   \textcolor{keywordflow}{if}(Mode == MODE_ENCRYPT) \textcolor{comment}{/* DES encryption */}
00209   \{
00210      DES\_CRYP\_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
00211   \}
00212   \textcolor{keywordflow}{else} \textcolor{comment}{/*if(Mode == MODE\_DECRYPT)*/} \textcolor{comment}{/* DES decryption */}
00213   \{
00214      DES\_CRYP\_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
00215   \}
00216 
00217   DES\_CRYP\_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
00218   DES\_CRYP\_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00219   CRYP_Init(&DES\_CRYP\_InitStructure);
00220 
00221   \textcolor{comment}{/* Key Initialisation */}
00222   DES\_CRYP\_KeyInitStructure.CRYP_Key1Left = \_\_REV(*(uint32\_t*)(keyaddr));
00223   keyaddr+=4;
00224   DES\_CRYP\_KeyInitStructure.CRYP_Key1Right= \_\_REV(*(uint32\_t*)(keyaddr));
00225   CRYP_KeyInit(& DES\_CRYP\_KeyInitStructure);
00226 
00227   \textcolor{comment}{/* Initialization Vectors */}
00228   DES\_CRYP\_IVInitStructure.CRYP_IV0Left = \_\_REV(*(uint32\_t*)(ivaddr));
00229   ivaddr+=4;
00230   DES\_CRYP\_IVInitStructure.CRYP_IV0Right= \_\_REV(*(uint32\_t*)(ivaddr));
00231   CRYP_IVInit(&DES\_CRYP\_IVInitStructure);
00232 
00233   \textcolor{comment}{/* Flush IN/OUT FIFO */}
00234   CRYP_FIFOFlush();
00235   
00236   \textcolor{comment}{/* Enable Crypto processor */}
00237   CRYP_Cmd(ENABLE);
00238 
00239   \textcolor{keywordflow}{for}(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
00240   \{
00241     \textcolor{comment}{/* Write the Input block in the Input FIFO */}
00242     CRYP_DataIn(*(uint32\_t*)(inputaddr));
00243     inputaddr+=4;
00244     CRYP_DataIn(*(uint32\_t*)(inputaddr));
00245     inputaddr+=4;
00246 
00247     \textcolor{comment}{/* Wait until the complete message has been processed */}
00248     counter = 0;
00249     \textcolor{keywordflow}{do}
00250     \{
00251       busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00252       counter++;
00253     \}\textcolor{keywordflow}{while} ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
00254 
00255     \textcolor{keywordflow}{if} (busystatus != RESET)
00256    \{
00257        status = ERROR;
00258     \}
00259     \textcolor{keywordflow}{else}
00260     \{
00261       \textcolor{comment}{/* Read the Output block from the Output FIFO */}
00262       *(uint32\_t*)(outputaddr) = CRYP_DataOut();
00263       outputaddr+=4;
00264       *(uint32\_t*)(outputaddr) = CRYP_DataOut();
00265       outputaddr+=4;
00266     \}
00267   \}
00268 
00269   \textcolor{comment}{/* Disable Crypto */}
00270   CRYP_Cmd(DISABLE);
00271 
00272   \textcolor{keywordflow}{return} status; 
00273 \}
\end{DoxyCode}
\mbox{\label{group__CRYP__Group8_ga3b96b7608b39197209abed5f5845f590}} 
\index{High Level D\+E\+S functions@{High Level D\+E\+S functions}!C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB@{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB}}
\index{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB@{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB}!High Level D\+E\+S functions@{High Level D\+E\+S functions}}
\subsubsection{C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+C\+B()}
{\footnotesize\ttfamily \textbf{ Error\+Status} C\+R\+Y\+P\+\_\+\+D\+E\+S\+\_\+\+E\+CB (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{Mode,  }\item[{uint8\+\_\+t}]{Key[8],  }\item[{uint8\+\_\+t $\ast$}]{Input,  }\item[{uint32\+\_\+t}]{Ilength,  }\item[{uint8\+\_\+t $\ast$}]{Output }\end{DoxyParamCaption})}



Encrypt and decrypt using D\+ES in E\+CB Mode. 


\begin{DoxyParams}{Parameters}
{\em Mode} & encryption or decryption Mode. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item M\+O\+D\+E\+\_\+\+E\+N\+C\+R\+Y\+PT\+: Encryption \item M\+O\+D\+E\+\_\+\+D\+E\+C\+R\+Y\+PT\+: Decryption \end{DoxyItemize}
\\
\hline
{\em Key} & Key used for D\+ES algorithm. \\
\hline
{\em Ilength} & length of the Input buffer, must be a multiple of 8. \\
\hline
{\em Input} & pointer to the Input buffer. \\
\hline
{\em Output} & pointer to the returned buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em An} & Error\+Status enumeration value\+:
\begin{DoxyItemize}
\item S\+U\+C\+C\+E\+SS\+: Operation done
\item E\+R\+R\+OR\+: Operation failed 
\end{DoxyItemize}\\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 94} of file \textbf{ stm32f4xx\+\_\+cryp\+\_\+des.\+c}.



References \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Algo\+Dir}, \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Algo\+Mode}, \textbf{ C\+R\+Y\+P\+\_\+\+Cmd()}, \textbf{ C\+R\+Y\+P\+\_\+\+Init\+Type\+Def\+::\+C\+R\+Y\+P\+\_\+\+Data\+Type}, \textbf{ C\+R\+Y\+P\+\_\+\+F\+I\+F\+O\+Flush()}, \textbf{ C\+R\+Y\+P\+\_\+\+Init()}, \textbf{ C\+R\+Y\+P\+\_\+\+Key\+Init()}, \textbf{ C\+R\+Y\+P\+\_\+\+Key\+Struct\+Init()}, \textbf{ D\+I\+S\+A\+B\+LE}, \textbf{ E\+N\+A\+B\+LE}, and \textbf{ S\+U\+C\+C\+E\+SS}.


\begin{DoxyCode}
00096 \{
00097   CRYP_InitTypeDef DES\_CRYP\_InitStructure;
00098   CRYP_KeyInitTypeDef DES\_CRYP\_KeyInitStructure;
00099   \_\_IO uint32\_t counter = 0;
00100   uint32\_t busystatus = 0;
00101   ErrorStatus status = SUCCESS;
00102   uint32\_t keyaddr    = (uint32\_t)Key;
00103   uint32\_t inputaddr  = (uint32\_t)Input;
00104   uint32\_t outputaddr = (uint32\_t)Output;
00105   uint32\_t i = 0;
00106 
00107   \textcolor{comment}{/* Crypto structures initialisation*/}
00108   CRYP_KeyStructInit(&DES\_CRYP\_KeyInitStructure);
00109 
00110   \textcolor{comment}{/* Crypto Init for Encryption process */}
00111   \textcolor{keywordflow}{if}( Mode == MODE_ENCRYPT ) \textcolor{comment}{/* DES encryption */}
00112   \{
00113      DES\_CRYP\_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
00114   \}
00115   \textcolor{keywordflow}{else}\textcolor{comment}{/* if( Mode == MODE\_DECRYPT )*/} \textcolor{comment}{/* DES decryption */}
00116   \{      
00117      DES\_CRYP\_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
00118   \}
00119 
00120   DES\_CRYP\_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
00121   DES\_CRYP\_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00122   CRYP_Init(&DES\_CRYP\_InitStructure);
00123 
00124   \textcolor{comment}{/* Key Initialisation */}
00125   DES\_CRYP\_KeyInitStructure.CRYP_Key1Left = \_\_REV(*(uint32\_t*)(keyaddr));
00126   keyaddr+=4;
00127   DES\_CRYP\_KeyInitStructure.CRYP_Key1Right= \_\_REV(*(uint32\_t*)(keyaddr));
00128   CRYP_KeyInit(& DES\_CRYP\_KeyInitStructure);
00129 
00130   \textcolor{comment}{/* Flush IN/OUT FIFO */}
00131   CRYP_FIFOFlush();
00132 
00133   \textcolor{comment}{/* Enable Crypto processor */}
00134   CRYP_Cmd(ENABLE);
00135 
00136   \textcolor{keywordflow}{for}(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
00137   \{
00138 
00139     \textcolor{comment}{/* Write the Input block in the Input FIFO */}
00140     CRYP_DataIn(*(uint32\_t*)(inputaddr));
00141     inputaddr+=4;
00142     CRYP_DataIn(*(uint32\_t*)(inputaddr));
00143     inputaddr+=4;
00144 
00145 \textcolor{comment}{/* Wait until the complete message has been processed */}
00146     counter = 0;
00147     \textcolor{keywordflow}{do}
00148     \{
00149       busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00150       counter++;
00151     \}\textcolor{keywordflow}{while} ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
00152 
00153     \textcolor{keywordflow}{if} (busystatus != RESET)
00154    \{
00155        status = ERROR;
00156     \}
00157     \textcolor{keywordflow}{else}
00158     \{
00159 
00160       \textcolor{comment}{/* Read the Output block from the Output FIFO */}
00161       *(uint32\_t*)(outputaddr) = CRYP_DataOut();
00162       outputaddr+=4;
00163       *(uint32\_t*)(outputaddr) = CRYP_DataOut();
00164       outputaddr+=4;
00165     \}
00166   \}
00167 
00168   \textcolor{comment}{/* Disable Crypto */}
00169   CRYP_Cmd(DISABLE);
00170 
00171   \textcolor{keywordflow}{return} status; 
00172 \}
\end{DoxyCode}
