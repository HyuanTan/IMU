\section{A\+DC}
\label{group__ADC}\index{A\+DC@{A\+DC}}


A\+DC driver modules.  


\subsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\textbf{ A\+D\+C\+\_\+\+Exported\+\_\+\+Constants}
\item 
\textbf{ A\+D\+C\+\_\+\+Private\+\_\+\+Functions}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def}
\begin{DoxyCompactList}\small\item\em A\+DC Init structure definition. \end{DoxyCompactList}\item 
struct \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def}
\begin{DoxyCompactList}\small\item\em A\+DC Common Init structure definition. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F\+F\+F1\+F\+F\+F)
\item 
\#define \textbf{ C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F\+F\+F\+F\+F\+E0)
\item 
\#define \textbf{ C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F3\+F\+F\+D\+F\+F)
\item 
\#define \textbf{ C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}~((uint32\+\_\+t)0x\+F\+C\+F\+F\+F\+E\+F\+F)
\item 
\#define \textbf{ C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+C\+F\+F\+F\+F\+F\+F\+F)
\item 
\#define \textbf{ C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F\+C\+F\+F\+F\+F\+F)
\item 
\#define \textbf{ C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F\+F0\+F\+F\+F\+F)
\item 
\#define \textbf{ C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}~((uint32\+\_\+t)0x\+C0\+F\+F\+F7\+F\+D)
\item 
\#define \textbf{ S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET}~((uint32\+\_\+t)0x0000001\+F)
\item 
\#define \textbf{ S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET}~((uint32\+\_\+t)0x0000001\+F)
\item 
\#define \textbf{ S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET}~((uint32\+\_\+t)0x0000001\+F)
\item 
\#define \textbf{ S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F0\+F\+F\+F\+F\+F)
\item 
\#define \textbf{ J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET}~((uint32\+\_\+t)0x0000001\+F)
\item 
\#define \textbf{ J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET}~((uint32\+\_\+t)0x00300000)
\item 
\#define \textbf{ J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET}~((uint32\+\_\+t)0x\+F\+F\+C\+F\+F\+F\+F\+F)
\item 
\#define \textbf{ S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET}~((uint32\+\_\+t)0x00000007)
\item 
\#define \textbf{ S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET}~((uint32\+\_\+t)0x00000007)
\item 
\#define \textbf{ J\+D\+R\+\_\+\+O\+F\+F\+S\+ET}~((uint8\+\_\+t)0x28)
\item 
\#define \textbf{ C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS}~((uint32\+\_\+t)0x40012308)
\item 
\#define \textbf{ C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}~((uint32\+\_\+t)0x\+F\+F\+F\+C30\+E0)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ A\+D\+C\+\_\+\+De\+Init} (void)
\begin{DoxyCompactList}\small\item\em Deinitializes all A\+D\+Cs peripherals registers to their default reset values. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Init} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def} $\ast$A\+D\+C\+\_\+\+Init\+Struct)
\begin{DoxyCompactList}\small\item\em Initializes the A\+D\+Cx peripheral according to the specified parameters in the A\+D\+C\+\_\+\+Init\+Struct. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Struct\+Init} (\textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def} $\ast$A\+D\+C\+\_\+\+Init\+Struct)
\begin{DoxyCompactList}\small\item\em Fills each A\+D\+C\+\_\+\+Init\+Struct member with its default value. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Common\+Init} (\textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def} $\ast$A\+D\+C\+\_\+\+Common\+Init\+Struct)
\begin{DoxyCompactList}\small\item\em Initializes the A\+D\+Cs peripherals according to the specified parameters in the A\+D\+C\+\_\+\+Common\+Init\+Struct. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Common\+Struct\+Init} (\textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def} $\ast$A\+D\+C\+\_\+\+Common\+Init\+Struct)
\begin{DoxyCompactList}\small\item\em Fills each A\+D\+C\+\_\+\+Common\+Init\+Struct member with its default value. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the specified A\+DC peripheral. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint32\+\_\+t A\+D\+C\+\_\+\+Analog\+Watchdog)
\begin{DoxyCompactList}\small\item\em Enables or disables the analog watchdog on single/all regular or injected channels. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint16\+\_\+t High\+Threshold, uint16\+\_\+t Low\+Threshold)
\begin{DoxyCompactList}\small\item\em Configures the high and low thresholds of the analog watchdog. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+Channel)
\begin{DoxyCompactList}\small\item\em Configures the analog watchdog guarded single channel. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd} (\textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the temperature sensor and Vrefint channels. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd} (\textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the V\+B\+AT (Voltage Battery) channel. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Regular\+Channel\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+Channel, uint8\+\_\+t Rank, uint8\+\_\+t A\+D\+C\+\_\+\+Sample\+Time)
\begin{DoxyCompactList}\small\item\em Configures for the selected A\+DC regular channel its corresponding rank in the sequencer and its sample time. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Software\+Start\+Conv} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx)
\begin{DoxyCompactList}\small\item\em Enables the selected A\+DC software start conversion of the regular channels. \end{DoxyCompactList}\item 
\textbf{ Flag\+Status} \textbf{ A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx)
\begin{DoxyCompactList}\small\item\em Gets the selected A\+DC Software start regular conversion Status. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the E\+OC on each regular channel conversion. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the A\+DC continuous conversion mode. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t Number)
\begin{DoxyCompactList}\small\item\em Configures the discontinuous mode for the selected A\+DC regular group channel. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Disc\+Mode\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the discontinuous mode on regular group channel for the specified A\+DC. \end{DoxyCompactList}\item 
uint16\+\_\+t \textbf{ A\+D\+C\+\_\+\+Get\+Conversion\+Value} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx)
\begin{DoxyCompactList}\small\item\em Returns the last A\+D\+Cx conversion result data for regular channel. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value} (void)
\begin{DoxyCompactList}\small\item\em Returns the last A\+D\+C1, A\+D\+C2 and A\+D\+C3 regular conversions results data in the selected multi mode. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+D\+M\+A\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the specified A\+DC D\+MA request. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the A\+DC D\+MA request after last transfer (Single-\/\+A\+DC mode) \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd} (\textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the A\+DC D\+MA request after last transfer in multi A\+DC mode. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Injected\+Channel\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+Channel, uint8\+\_\+t Rank, uint8\+\_\+t A\+D\+C\+\_\+\+Sample\+Time)
\begin{DoxyCompactList}\small\item\em Configures for the selected A\+DC injected channel its corresponding rank in the sequencer and its sample time. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t Length)
\begin{DoxyCompactList}\small\item\em Configures the sequencer length for injected channels. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Set\+Injected\+Offset} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+Injected\+Channel, uint16\+\_\+t Offset)
\begin{DoxyCompactList}\small\item\em Set the injected channels conversion value offset. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint32\+\_\+t A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv)
\begin{DoxyCompactList}\small\item\em Configures the A\+D\+Cx external trigger for injected channels conversion. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint32\+\_\+t A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge)
\begin{DoxyCompactList}\small\item\em Configures the A\+D\+Cx external trigger edge for injected channels conversion. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx)
\begin{DoxyCompactList}\small\item\em Enables the selected A\+DC software start conversion of the injected channels. \end{DoxyCompactList}\item 
\textbf{ Flag\+Status} \textbf{ A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx)
\begin{DoxyCompactList}\small\item\em Gets the selected A\+DC Software start injected conversion Status. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the selected A\+DC automatic injected group conversion after regular one. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the discontinuous mode for injected group channel for the specified A\+DC. \end{DoxyCompactList}\item 
uint16\+\_\+t \textbf{ A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+Injected\+Channel)
\begin{DoxyCompactList}\small\item\em Returns the A\+DC injected channel conversion result. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+I\+T\+Config} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint16\+\_\+t A\+D\+C\+\_\+\+IT, \textbf{ Functional\+State} New\+State)
\begin{DoxyCompactList}\small\item\em Enables or disables the specified A\+DC interrupts. \end{DoxyCompactList}\item 
\textbf{ Flag\+Status} \textbf{ A\+D\+C\+\_\+\+Get\+Flag\+Status} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+F\+L\+AG)
\begin{DoxyCompactList}\small\item\em Checks whether the specified A\+DC flag is set or not. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Clear\+Flag} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint8\+\_\+t A\+D\+C\+\_\+\+F\+L\+AG)
\begin{DoxyCompactList}\small\item\em Clears the A\+D\+Cx\textquotesingle{}s pending flags. \end{DoxyCompactList}\item 
\textbf{ I\+T\+Status} \textbf{ A\+D\+C\+\_\+\+Get\+I\+T\+Status} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint16\+\_\+t A\+D\+C\+\_\+\+IT)
\begin{DoxyCompactList}\small\item\em Checks whether the specified A\+DC interrupt has occurred or not. \end{DoxyCompactList}\item 
void \textbf{ A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit} (\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$A\+D\+Cx, uint16\+\_\+t A\+D\+C\+\_\+\+IT)
\begin{DoxyCompactList}\small\item\em Clears the A\+D\+Cx\textquotesingle{}s interrupt pending bits. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A\+DC driver modules. 



\subsection{Macro Definition Documentation}
\mbox{\label{group__ADC_ga92ecbad71393fbbf41b5d030ecc16899}} 
\index{A\+DC@{A\+DC}!C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS@{C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS}}
\index{C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS@{C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS}!A\+DC@{A\+DC}}
\subsubsection{C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS}
{\footnotesize\ttfamily \#define C\+D\+R\+\_\+\+A\+D\+D\+R\+E\+SS~((uint32\+\_\+t)0x40012308)}



Definition at line \textbf{ 160} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga7ad38f78fe4f6b0536c5a98c07c9bffe}} 
\index{A\+DC@{A\+DC}!C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET}}
\index{C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R1\+\_\+\+A\+W\+D\+C\+H\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F\+F\+F\+F\+F\+E0)}



Definition at line \textbf{ 117} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga8f64812f72e97a4bdd27684e20a79c39}} 
\index{A\+DC@{A\+DC}!C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET}}
\index{C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R1\+\_\+\+A\+W\+D\+Mode\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F3\+F\+F\+D\+F\+F)}



Definition at line \textbf{ 120} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga8d425258898b4af4ebc820f52635fad8}} 
\index{A\+DC@{A\+DC}!C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}}
\index{C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}!A\+DC@{A\+DC}}
\subsubsection{C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}
{\footnotesize\ttfamily \#define C\+R1\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK~((uint32\+\_\+t)0x\+F\+C\+F\+F\+F\+E\+F\+F)}



Definition at line \textbf{ 123} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gad932677d27cc1bb327c35adabfe2381f}} 
\index{A\+DC@{A\+DC}!C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET}}
\index{C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET@{C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R1\+\_\+\+D\+I\+S\+C\+N\+U\+M\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F\+F\+F1\+F\+F\+F)}



Definition at line \textbf{ 114} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga0ff3ffaedfe4137d35d9a975213a37a9}} 
\index{A\+DC@{A\+DC}!C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}}
\index{C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}!A\+DC@{A\+DC}}
\subsubsection{C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}
{\footnotesize\ttfamily \#define C\+R2\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK~((uint32\+\_\+t)0x\+C0\+F\+F\+F7\+F\+D)}



Definition at line \textbf{ 135} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga4df1935a73fac1021d127cd06f33b840}} 
\index{A\+DC@{A\+DC}!C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}}
\index{C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R2\+\_\+\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+C\+F\+F\+F\+F\+F\+F\+F)}



Definition at line \textbf{ 126} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gac33c62d66b5298288f0465c550e4891b}} 
\index{A\+DC@{A\+DC}!C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}}
\index{C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R2\+\_\+\+J\+E\+X\+T\+E\+N\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F\+C\+F\+F\+F\+F\+F)}



Definition at line \textbf{ 129} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga086e0cc4e32b2448cab2b5ba6d0651fb}} 
\index{A\+DC@{A\+DC}!C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET}}
\index{C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET@{C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define C\+R2\+\_\+\+J\+E\+X\+T\+S\+E\+L\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F\+F0\+F\+F\+F\+F)}



Definition at line \textbf{ 132} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga8a5812a1d5ced986bb997a4bb7ae697d}} 
\index{A\+DC@{A\+DC}!C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}}
\index{C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK@{C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}!A\+DC@{A\+DC}}
\subsubsection{C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK}
{\footnotesize\ttfamily \#define C\+R\+\_\+\+C\+L\+E\+A\+R\+\_\+\+M\+A\+SK~((uint32\+\_\+t)0x\+F\+F\+F\+C30\+E0)}



Definition at line \textbf{ 163} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gad2480fae33dfd1308157c313af8e6a5d}} 
\index{A\+DC@{A\+DC}!J\+D\+R\+\_\+\+O\+F\+F\+S\+ET@{J\+D\+R\+\_\+\+O\+F\+F\+S\+ET}}
\index{J\+D\+R\+\_\+\+O\+F\+F\+S\+ET@{J\+D\+R\+\_\+\+O\+F\+F\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{J\+D\+R\+\_\+\+O\+F\+F\+S\+ET}
{\footnotesize\ttfamily \#define J\+D\+R\+\_\+\+O\+F\+F\+S\+ET~((uint8\+\_\+t)0x28)}



Definition at line \textbf{ 157} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gaf129b56688ca71eb3a54f8d513f40067}} 
\index{A\+DC@{A\+DC}!J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET}}
\index{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F\+C\+F\+F\+F\+F\+F)}



Definition at line \textbf{ 150} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gaaee3ea0188e1d2b30d6d0e0a211c630d}} 
\index{A\+DC@{A\+DC}!J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET}}
\index{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define J\+S\+Q\+R\+\_\+\+J\+L\+\_\+\+S\+ET~((uint32\+\_\+t)0x00300000)}



Definition at line \textbf{ 149} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gac4cf4825da426e3ecdb87967854c834e}} 
\index{A\+DC@{A\+DC}!J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET}}
\index{J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET@{J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define J\+S\+Q\+R\+\_\+\+J\+S\+Q\+\_\+\+S\+ET~((uint32\+\_\+t)0x0000001\+F)}



Definition at line \textbf{ 146} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga844e95644b6b0ce035db737cf6a2f3ef}} 
\index{A\+DC@{A\+DC}!S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET@{S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET}}
\index{S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET@{S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define S\+M\+P\+R1\+\_\+\+S\+M\+P\+\_\+\+S\+ET~((uint32\+\_\+t)0x00000007)}



Definition at line \textbf{ 153} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga13b8e9e5253f17d6f1d6e68a6feb8947}} 
\index{A\+DC@{A\+DC}!S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET@{S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET}}
\index{S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET@{S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define S\+M\+P\+R2\+\_\+\+S\+M\+P\+\_\+\+S\+ET~((uint32\+\_\+t)0x00000007)}



Definition at line \textbf{ 154} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gaf7266f2602d12f1dca080669583aea4f}} 
\index{A\+DC@{A\+DC}!S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET@{S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET}}
\index{S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET@{S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define S\+Q\+R1\+\_\+\+L\+\_\+\+R\+E\+S\+ET~((uint32\+\_\+t)0x\+F\+F0\+F\+F\+F\+F\+F)}



Definition at line \textbf{ 143} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga72ecdac96f13a034c41f1e7f8ce3b45c}} 
\index{A\+DC@{A\+DC}!S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET}}
\index{S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define S\+Q\+R1\+\_\+\+S\+Q\+\_\+\+S\+ET~((uint32\+\_\+t)0x0000001\+F)}



Definition at line \textbf{ 140} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_ga39495128596ac3def40413414272f661}} 
\index{A\+DC@{A\+DC}!S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET}}
\index{S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define S\+Q\+R2\+\_\+\+S\+Q\+\_\+\+S\+ET~((uint32\+\_\+t)0x0000001\+F)}



Definition at line \textbf{ 139} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.

\mbox{\label{group__ADC_gaaed9be4552724197505e5e4d23fcf7df}} 
\index{A\+DC@{A\+DC}!S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET}}
\index{S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET@{S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET}!A\+DC@{A\+DC}}
\subsubsection{S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET}
{\footnotesize\ttfamily \#define S\+Q\+R3\+\_\+\+S\+Q\+\_\+\+S\+ET~((uint32\+\_\+t)0x0000001\+F)}



Definition at line \textbf{ 138} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



\subsection{Function Documentation}
\mbox{\label{group__ADC_gad017d69bec6e497afd35ba25ea22d86e}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd}}
\index{A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Analog\+Watchdog\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint32\+\_\+t}]{A\+D\+C\+\_\+\+Analog\+Watchdog }\end{DoxyParamCaption})}



Enables or disables the analog watchdog on single/all regular or injected channels. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Analog\+Watchdog} & the A\+DC analog watchdog configuration. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+Single\+Reg\+Enable\+: Analog watchdog on a single regular channel \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+Single\+Injec\+Enable\+: Analog watchdog on a single injected channel \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+Single\+Reg\+Or\+Injec\+Enable\+: Analog watchdog on a single regular or injected channel \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+All\+Reg\+Enable\+: Analog watchdog on all regular channel \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+All\+Injec\+Enable\+: Analog watchdog on all injected channel \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+All\+Reg\+All\+Injec\+Enable\+: Analog watchdog on all regular and injected channels \item A\+D\+C\+\_\+\+Analog\+Watchdog\+\_\+\+None\+: No channel guarded by the analog watchdog \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 450} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00451 \{
00452   uint32\_t tmpreg = 0;
00453   \textcolor{comment}{/* Check the parameters */}
00454   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00455   assert_param(IS_ADC_ANALOG_WATCHDOG(ADC\_AnalogWatchdog));
00456   
00457   \textcolor{comment}{/* Get the old register value */}
00458   tmpreg = ADCx->CR1;
00459   
00460   \textcolor{comment}{/* Clear AWDEN, JAWDEN and AWDSGL bits */}
00461   tmpreg &= CR1_AWDMode_RESET;
00462   
00463   \textcolor{comment}{/* Set the analog watchdog enable mode */}
00464   tmpreg |= ADC\_AnalogWatchdog;
00465   
00466   \textcolor{comment}{/* Store the new register value */}
00467   ADCx->CR1 = tmpreg;
00468 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga03cef3d12292ffa2b8520524d5b0226c}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config}}
\index{A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Analog\+Watchdog\+Single\+Channel\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Channel }\end{DoxyParamCaption})}



Configures the analog watchdog guarded single channel. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Channel} & the A\+DC channel to configure for the analog watchdog. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Channel\+\_\+0\+: A\+DC Channel0 selected \item A\+D\+C\+\_\+\+Channel\+\_\+1\+: A\+DC Channel1 selected \item A\+D\+C\+\_\+\+Channel\+\_\+2\+: A\+DC Channel2 selected \item A\+D\+C\+\_\+\+Channel\+\_\+3\+: A\+DC Channel3 selected \item A\+D\+C\+\_\+\+Channel\+\_\+4\+: A\+DC Channel4 selected \item A\+D\+C\+\_\+\+Channel\+\_\+5\+: A\+DC Channel5 selected \item A\+D\+C\+\_\+\+Channel\+\_\+6\+: A\+DC Channel6 selected \item A\+D\+C\+\_\+\+Channel\+\_\+7\+: A\+DC Channel7 selected \item A\+D\+C\+\_\+\+Channel\+\_\+8\+: A\+DC Channel8 selected \item A\+D\+C\+\_\+\+Channel\+\_\+9\+: A\+DC Channel9 selected \item A\+D\+C\+\_\+\+Channel\+\_\+10\+: A\+DC Channel10 selected \item A\+D\+C\+\_\+\+Channel\+\_\+11\+: A\+DC Channel11 selected \item A\+D\+C\+\_\+\+Channel\+\_\+12\+: A\+DC Channel12 selected \item A\+D\+C\+\_\+\+Channel\+\_\+13\+: A\+DC Channel13 selected \item A\+D\+C\+\_\+\+Channel\+\_\+14\+: A\+DC Channel14 selected \item A\+D\+C\+\_\+\+Channel\+\_\+15\+: A\+DC Channel15 selected \item A\+D\+C\+\_\+\+Channel\+\_\+16\+: A\+DC Channel16 selected \item A\+D\+C\+\_\+\+Channel\+\_\+17\+: A\+DC Channel17 selected \item A\+D\+C\+\_\+\+Channel\+\_\+18\+: A\+DC Channel18 selected \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 520} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00521 \{
00522   uint32\_t tmpreg = 0;
00523   \textcolor{comment}{/* Check the parameters */}
00524   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00525   assert_param(IS_ADC_CHANNEL(ADC\_Channel));
00526   
00527   \textcolor{comment}{/* Get the old register value */}
00528   tmpreg = ADCx->CR1;
00529   
00530   \textcolor{comment}{/* Clear the Analog watchdog channel select bits */}
00531   tmpreg &= CR1_AWDCH_RESET;
00532   
00533   \textcolor{comment}{/* Set the Analog watchdog channel */}
00534   tmpreg |= ADC\_Channel;
00535   
00536   \textcolor{comment}{/* Store the new register value */}
00537   ADCx->CR1 = tmpreg;
00538 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga79588d02aa8e4147f21cb90a4708366d}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config}}
\index{A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config@{A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Analog\+Watchdog\+Thresholds\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint16\+\_\+t}]{High\+Threshold,  }\item[{uint16\+\_\+t}]{Low\+Threshold }\end{DoxyParamCaption})}



Configures the high and low thresholds of the analog watchdog. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em High\+Threshold} & the A\+DC analog watchdog High threshold value. This parameter must be a 12-\/bit value. \\
\hline
{\em Low\+Threshold} & the A\+DC analog watchdog Low threshold value. This parameter must be a 12-\/bit value. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 479} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00481 \{
00482   \textcolor{comment}{/* Check the parameters */}
00483   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00484   assert_param(IS_ADC_THRESHOLD(HighThreshold));
00485   assert_param(IS_ADC_THRESHOLD(LowThreshold));
00486   
00487   \textcolor{comment}{/* Set the ADCx high threshold */}
00488   ADCx->HTR = HighThreshold;
00489   
00490   \textcolor{comment}{/* Set the ADCx low threshold */}
00491   ADCx->LTR = LowThreshold;
00492 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga1ff9c3b8e4bbdd2addfd227f1a506a66}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd@{A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd}}
\index{A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd@{A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Auto\+Injected\+Conv\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the selected A\+DC automatic injected group conversion after regular one. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC auto injected conversion This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1419} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01420 \{
01421   \textcolor{comment}{/* Check the parameters */}
01422   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01423   assert_param(IS_FUNCTIONAL_STATE(NewState));
01424   \textcolor{keywordflow}{if} (NewState != DISABLE)
01425   \{
01426     \textcolor{comment}{/* Enable the selected ADC automatic injected group conversion */}
01427     ADCx->CR1 |= (uint32\_t)ADC_CR1_JAUTO;
01428   \}
01429   \textcolor{keywordflow}{else}
01430   \{
01431     \textcolor{comment}{/* Disable the selected ADC automatic injected group conversion */}
01432     ADCx->CR1 &= (uint32\_t)(~ADC_CR1_JAUTO);
01433   \}
01434 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gaf34f36798f811b4a41321ea2d12118d4}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Clear\+Flag@{A\+D\+C\+\_\+\+Clear\+Flag}}
\index{A\+D\+C\+\_\+\+Clear\+Flag@{A\+D\+C\+\_\+\+Clear\+Flag}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Clear\+Flag()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Clear\+Flag (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+F\+L\+AG }\end{DoxyParamCaption})}



Clears the A\+D\+Cx\textquotesingle{}s pending flags. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+F\+L\+AG} & specifies the flag to clear. This parameter can be any combination of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+A\+WD\+: Analog watchdog flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+E\+OC\+: End of conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+J\+E\+OC\+: End of injected group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+J\+S\+T\+RT\+: Start of injected group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+S\+T\+RT\+: Start of regular group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+O\+VR\+: Overrun flag \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1653} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01654 \{
01655   \textcolor{comment}{/* Check the parameters */}
01656   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01657   assert_param(IS_ADC_CLEAR_FLAG(ADC\_FLAG));
01658 
01659   \textcolor{comment}{/* Clear the selected ADC flags */}
01660   ADCx->SR = ~(uint32\_t)ADC\_FLAG;
01661 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga601c6a67bd883eb631ecc7aa5e999b9c}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit@{A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit}}
\index{A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit@{A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Clear\+I\+T\+Pending\+Bit (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint16\+\_\+t}]{A\+D\+C\+\_\+\+IT }\end{DoxyParamCaption})}



Clears the A\+D\+Cx\textquotesingle{}s interrupt pending bits. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+IT} & specifies the A\+DC interrupt pending bit to clear. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+I\+T\+\_\+\+E\+OC\+: End of conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+A\+WD\+: Analog watchdog interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+J\+E\+OC\+: End of injected conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+O\+VR\+: Overrun interrupt mask \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1715} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01716 \{
01717   uint8\_t itmask = 0;
01718   \textcolor{comment}{/* Check the parameters */}
01719   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01720   assert_param(IS_ADC_IT(ADC\_IT)); 
01721   \textcolor{comment}{/* Get the ADC IT index */}
01722   itmask = (uint8\_t)(ADC\_IT >> 8);
01723   \textcolor{comment}{/* Clear the selected ADC interrupt pending bits */}
01724   ADCx->SR = ~(uint32\_t)itmask;
01725 \}                    
\end{DoxyCode}
\mbox{\label{group__ADC_ga40882d399e3371755ed610c1134e634e}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Cmd@{A\+D\+C\+\_\+\+Cmd}}
\index{A\+D\+C\+\_\+\+Cmd@{A\+D\+C\+\_\+\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the specified A\+DC peripheral. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the A\+D\+Cx peripheral. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 392} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00393 \{
00394   \textcolor{comment}{/* Check the parameters */}
00395   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00396   assert_param(IS_FUNCTIONAL_STATE(NewState));
00397   \textcolor{keywordflow}{if} (NewState != DISABLE)
00398   \{
00399     \textcolor{comment}{/* Set the ADON bit to wake up the ADC from power down mode */}
00400     ADCx->CR2 |= (uint32\_t)ADC_CR2_ADON;
00401   \}
00402   \textcolor{keywordflow}{else}
00403   \{
00404     \textcolor{comment}{/* Disable the selected ADC peripheral */}
00405     ADCx->CR2 &= (uint32\_t)(~ADC_CR2_ADON);
00406   \}
00407 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga5803f6581a9cd7e90b6e637067102d94}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Common\+Init@{A\+D\+C\+\_\+\+Common\+Init}}
\index{A\+D\+C\+\_\+\+Common\+Init@{A\+D\+C\+\_\+\+Common\+Init}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Common\+Init()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Common\+Init (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def} $\ast$}]{A\+D\+C\+\_\+\+Common\+Init\+Struct }\end{DoxyParamCaption})}



Initializes the A\+D\+Cs peripherals according to the specified parameters in the A\+D\+C\+\_\+\+Common\+Init\+Struct. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+C\+\_\+\+Common\+Init\+Struct} & pointer to an \doxyref{A\+D\+C\+\_\+\+Common\+Init\+Type\+Def}{p.}{structADC__CommonInitTypeDef} structure that contains the configuration information for All A\+D\+Cs peripherals. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 334} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode}, \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Mode}, \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Prescaler}, and \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Two\+Sampling\+Delay}.


\begin{DoxyCode}
00335 \{
00336   uint32\_t tmpreg1 = 0;
00337   \textcolor{comment}{/* Check the parameters */}
00338   assert_param(IS_ADC_MODE(ADC\_CommonInitStruct->ADC_Mode));
00339   assert_param(IS_ADC_PRESCALER(ADC\_CommonInitStruct->ADC_Prescaler));
00340   assert_param(IS_ADC_DMA_ACCESS_MODE(ADC\_CommonInitStruct->ADC_DMAAccessMode));
00341   assert_param(IS_ADC_SAMPLING_DELAY(ADC\_CommonInitStruct->ADC_TwoSamplingDelay));
00342   \textcolor{comment}{/*---------------------------- ADC CCR Configuration -----------------*/}
00343   \textcolor{comment}{/* Get the ADC CCR value */}
00344   tmpreg1 = ADC->CCR;
00345   
00346   \textcolor{comment}{/* Clear MULTI, DELAY, DMA and ADCPRE bits */}
00347   tmpreg1 &= CR_CLEAR_MASK;
00348   
00349   \textcolor{comment}{/* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,}
00350 \textcolor{comment}{     and DMA access mode for multimode */}
00351   \textcolor{comment}{/* Set MULTI bits according to ADC\_Mode value */}
00352   \textcolor{comment}{/* Set ADCPRE bits according to ADC\_Prescaler value */}
00353   \textcolor{comment}{/* Set DMA bits according to ADC\_DMAAccessMode value */}
00354   \textcolor{comment}{/* Set DELAY bits according to ADC\_TwoSamplingDelay value */}    
00355   tmpreg1 |= (uint32\_t)(ADC\_CommonInitStruct->ADC_Mode | 
00356                         ADC\_CommonInitStruct->ADC_Prescaler | 
00357                         ADC\_CommonInitStruct->ADC_DMAAccessMode | 
00358                         ADC\_CommonInitStruct->ADC_TwoSamplingDelay);
00359                         
00360   \textcolor{comment}{/* Write to ADC CCR */}
00361   ADC->CCR = tmpreg1;
00362 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gad60a6414b4932c704f6f7a7c2963fa2a}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Common\+Struct\+Init@{A\+D\+C\+\_\+\+Common\+Struct\+Init}}
\index{A\+D\+C\+\_\+\+Common\+Struct\+Init@{A\+D\+C\+\_\+\+Common\+Struct\+Init}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Common\+Struct\+Init()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Common\+Struct\+Init (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def} $\ast$}]{A\+D\+C\+\_\+\+Common\+Init\+Struct }\end{DoxyParamCaption})}



Fills each A\+D\+C\+\_\+\+Common\+Init\+Struct member with its default value. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+C\+\_\+\+Common\+Init\+Struct} & pointer to an \doxyref{A\+D\+C\+\_\+\+Common\+Init\+Type\+Def}{p.}{structADC__CommonInitTypeDef} structure which will be initialized. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 370} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode}, \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Mode}, \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Prescaler}, and \textbf{ A\+D\+C\+\_\+\+Common\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Two\+Sampling\+Delay}.


\begin{DoxyCode}
00371 \{
00372   \textcolor{comment}{/* Initialize the ADC\_Mode member */}
00373   ADC\_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
00374 
00375   \textcolor{comment}{/* initialize the ADC\_Prescaler member */}
00376   ADC\_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
00377 
00378   \textcolor{comment}{/* Initialize the ADC\_DMAAccessMode member */}
00379   ADC\_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00380 
00381   \textcolor{comment}{/* Initialize the ADC\_TwoSamplingDelay member */}
00382   ADC\_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
00383 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga879d70e9345d35688590938503f961db}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd@{A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd}}
\index{A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd@{A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Continuous\+Mode\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the A\+DC continuous conversion mode. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC continuous conversion mode This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 897} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00898 \{
00899   \textcolor{comment}{/* Check the parameters */}
00900   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00901   assert_param(IS_FUNCTIONAL_STATE(NewState));
00902   
00903   \textcolor{keywordflow}{if} (NewState != DISABLE)
00904   \{
00905     \textcolor{comment}{/* Enable the selected ADC continuous conversion mode */}
00906     ADCx->CR2 |= (uint32\_t)ADC_CR2_CONT;
00907   \}
00908   \textcolor{keywordflow}{else}
00909   \{
00910     \textcolor{comment}{/* Disable the selected ADC continuous conversion mode */}
00911     ADCx->CR2 &= (uint32\_t)(~ADC_CR2_CONT);
00912   \}
00913 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga1962afdd9eebe5c896bbba2e4f26fe09}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+De\+Init@{A\+D\+C\+\_\+\+De\+Init}}
\index{A\+D\+C\+\_\+\+De\+Init@{A\+D\+C\+\_\+\+De\+Init}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+De\+Init()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+De\+Init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Deinitializes all A\+D\+Cs peripherals registers to their default reset values. 


\begin{DoxyParams}{Parameters}
{\em None} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 206} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}, \textbf{ E\+N\+A\+B\+LE}, and \textbf{ R\+C\+C\+\_\+\+A\+P\+B2\+Periph\+Reset\+Cmd()}.


\begin{DoxyCode}
00207 \{
00208   \textcolor{comment}{/* Enable all ADCs reset state */}
00209   RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
00210   
00211   \textcolor{comment}{/* Release all ADCs from reset state */}
00212   RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
00213 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga6eb241ba82d67d1371136c9132083937}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config@{A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config}}
\index{A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config@{A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Disc\+Mode\+Channel\+Count\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{Number }\end{DoxyParamCaption})}



Configures the discontinuous mode for the selected A\+DC regular group channel. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em Number} & specifies the discontinuous mode regular channel count value. This number must be between 1 and 8. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 923} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00924 \{
00925   uint32\_t tmpreg1 = 0;
00926   uint32\_t tmpreg2 = 0;
00927   
00928   \textcolor{comment}{/* Check the parameters */}
00929   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00930   assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
00931   
00932   \textcolor{comment}{/* Get the old register value */}
00933   tmpreg1 = ADCx->CR1;
00934   
00935   \textcolor{comment}{/* Clear the old discontinuous mode channel count */}
00936   tmpreg1 &= CR1_DISCNUM_RESET;
00937   
00938   \textcolor{comment}{/* Set the discontinuous mode channel count */}
00939   tmpreg2 = Number - 1;
00940   tmpreg1 |= tmpreg2 << 13;
00941   
00942   \textcolor{comment}{/* Store the new register value */}
00943   ADCx->CR1 = tmpreg1;
00944 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga1909649d10253ce88d986ffbb94a4be6}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Disc\+Mode\+Cmd@{A\+D\+C\+\_\+\+Disc\+Mode\+Cmd}}
\index{A\+D\+C\+\_\+\+Disc\+Mode\+Cmd@{A\+D\+C\+\_\+\+Disc\+Mode\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Disc\+Mode\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Disc\+Mode\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the discontinuous mode on regular group channel for the specified A\+DC. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC discontinuous mode on regular group channel. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 955} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00956 \{
00957   \textcolor{comment}{/* Check the parameters */}
00958   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00959   assert_param(IS_FUNCTIONAL_STATE(NewState));
00960   
00961   \textcolor{keywordflow}{if} (NewState != DISABLE)
00962   \{
00963     \textcolor{comment}{/* Enable the selected ADC regular discontinuous mode */}
00964     ADCx->CR1 |= (uint32\_t)ADC_CR1_DISCEN;
00965   \}
00966   \textcolor{keywordflow}{else}
00967   \{
00968     \textcolor{comment}{/* Disable the selected ADC regular discontinuous mode */}
00969     ADCx->CR1 &= (uint32\_t)(~ADC_CR1_DISCEN);
00970   \}
00971 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gac5881d5995818001584b27b137a8dbcb}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+D\+M\+A\+Cmd@{A\+D\+C\+\_\+\+D\+M\+A\+Cmd}}
\index{A\+D\+C\+\_\+\+D\+M\+A\+Cmd@{A\+D\+C\+\_\+\+D\+M\+A\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+D\+M\+A\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+D\+M\+A\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the specified A\+DC D\+MA request. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC D\+MA transfer. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1048} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01049 \{
01050   \textcolor{comment}{/* Check the parameters */}
01051   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01052   assert_param(IS_FUNCTIONAL_STATE(NewState));
01053   \textcolor{keywordflow}{if} (NewState != DISABLE)
01054   \{
01055     \textcolor{comment}{/* Enable the selected ADC DMA request */}
01056     ADCx->CR2 |= (uint32\_t)ADC_CR2_DMA;
01057   \}
01058   \textcolor{keywordflow}{else}
01059   \{
01060     \textcolor{comment}{/* Disable the selected ADC DMA request */}
01061     ADCx->CR2 &= (uint32\_t)(~ADC_CR2_DMA);
01062   \}
01063 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga912fd3e923ae4435621724e1bbc52729}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd@{A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd}}
\index{A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd@{A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the A\+DC D\+MA request after last transfer (Single-\/\+A\+DC mode) 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC D\+MA request after last transfer. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1072} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01073 \{
01074   \textcolor{comment}{/* Check the parameters */}
01075   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01076   assert_param(IS_FUNCTIONAL_STATE(NewState));
01077   \textcolor{keywordflow}{if} (NewState != DISABLE)
01078   \{
01079     \textcolor{comment}{/* Enable the selected ADC DMA request after last transfer */}
01080     ADCx->CR2 |= (uint32\_t)ADC_CR2_DDS;
01081   \}
01082   \textcolor{keywordflow}{else}
01083   \{
01084     \textcolor{comment}{/* Disable the selected ADC DMA request after last transfer */}
01085     ADCx->CR2 &= (uint32\_t)(~ADC_CR2_DDS);
01086   \}
01087 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga5316caaa170415ef171c486d8f0bf22d}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd@{A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd}}
\index{A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd@{A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+E\+O\+C\+On\+Each\+Regular\+Channel\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the E\+OC on each regular channel conversion. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC E\+OC flag rising This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 872} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00873 \{
00874   \textcolor{comment}{/* Check the parameters */}
00875   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00876   assert_param(IS_FUNCTIONAL_STATE(NewState));
00877   
00878   \textcolor{keywordflow}{if} (NewState != DISABLE)
00879   \{
00880     \textcolor{comment}{/* Enable the selected ADC EOC rising on each regular channel conversion */}
00881     ADCx->CR2 |= (uint32\_t)ADC_CR2_EOCS;
00882   \}
00883   \textcolor{keywordflow}{else}
00884   \{
00885     \textcolor{comment}{/* Disable the selected ADC EOC rising on each regular channel conversion */}
00886     ADCx->CR2 &= (uint32\_t)(~ADC_CR2_EOCS);
00887   \}
00888 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gafc02ce1e84e96b692adf085f61a0bca6}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config@{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config}}
\index{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config@{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint32\+\_\+t}]{A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv }\end{DoxyParamCaption})}



Configures the A\+D\+Cx external trigger for injected channels conversion. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv} & specifies the A\+DC trigger to start injected conversion. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T1\+\_\+\+C\+C4\+: Timer1 capture compare4 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T1\+\_\+\+T\+R\+GO\+: Timer1 T\+R\+GO event selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T2\+\_\+\+C\+C1\+: Timer2 capture compare1 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T2\+\_\+\+T\+R\+GO\+: Timer2 T\+R\+GO event selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T3\+\_\+\+C\+C2\+: Timer3 capture compare2 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T3\+\_\+\+C\+C4\+: Timer3 capture compare4 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T4\+\_\+\+C\+C1\+: Timer4 capture compare1 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T4\+\_\+\+C\+C2\+: Timer4 capture compare2 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T4\+\_\+\+C\+C3\+: Timer4 capture compare3 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T4\+\_\+\+T\+R\+GO\+: Timer4 T\+R\+GO event selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T5\+\_\+\+C\+C4\+: Timer5 capture compare4 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T5\+\_\+\+T\+R\+GO\+: Timer5 T\+R\+GO event selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T8\+\_\+\+C\+C2\+: Timer8 capture compare2 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T8\+\_\+\+C\+C3\+: Timer8 capture compare3 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+T8\+\_\+\+C\+C4\+: Timer8 capture compare4 selected \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+\_\+\+Ext\+\_\+\+I\+T15\+: External interrupt line 15 event selected \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1322} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01323 \{
01324   uint32\_t tmpreg = 0;
01325   \textcolor{comment}{/* Check the parameters */}
01326   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01327   assert_param(IS_ADC_EXT_INJEC_TRIG(ADC\_ExternalTrigInjecConv));
01328   
01329   \textcolor{comment}{/* Get the old register value */}
01330   tmpreg = ADCx->CR2;
01331   
01332   \textcolor{comment}{/* Clear the old external event selection for injected group */}
01333   tmpreg &= CR2_JEXTSEL_RESET;
01334   
01335   \textcolor{comment}{/* Set the external event selection for injected group */}
01336   tmpreg |= ADC\_ExternalTrigInjecConv;
01337   
01338   \textcolor{comment}{/* Store the new register value */}
01339   ADCx->CR2 = tmpreg;
01340 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga62bea56579f04374fbe830d9e55e6fb0}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config@{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config}}
\index{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config@{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+External\+Trig\+Injected\+Conv\+Edge\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint32\+\_\+t}]{A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge }\end{DoxyParamCaption})}



Configures the A\+D\+Cx external trigger edge for injected channels conversion. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge} & specifies the A\+DC external trigger edge to start injected conversion. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge\+\_\+\+None\+: external trigger disabled for injected conversion \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge\+\_\+\+Rising\+: detection on rising edge \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge\+\_\+\+Falling\+: detection on falling edge \item A\+D\+C\+\_\+\+External\+Trig\+Injec\+Conv\+Edge\+\_\+\+Rising\+Falling\+: detection on both rising and falling edge \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1356} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01357 \{
01358   uint32\_t tmpreg = 0;
01359   \textcolor{comment}{/* Check the parameters */}
01360   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01361   assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC\_ExternalTrigInjecConvEdge));
01362   \textcolor{comment}{/* Get the old register value */}
01363   tmpreg = ADCx->CR2;
01364   \textcolor{comment}{/* Clear the old external trigger edge for injected group */}
01365   tmpreg &= CR2_JEXTEN_RESET;
01366   \textcolor{comment}{/* Set the new external trigger edge for injected group */}
01367   tmpreg |= ADC\_ExternalTrigInjecConvEdge;
01368   \textcolor{comment}{/* Store the new register value */}
01369   ADCx->CR2 = tmpreg;
01370 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gaaf74221c285ec5dab5e66baf7bec6bd3}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Conversion\+Value}}
\index{A\+D\+C\+\_\+\+Get\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Conversion\+Value}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Conversion\+Value()}
{\footnotesize\ttfamily uint16\+\_\+t A\+D\+C\+\_\+\+Get\+Conversion\+Value (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx }\end{DoxyParamCaption})}



Returns the last A\+D\+Cx conversion result data for regular channel. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & Data conversion value. \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 978} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00979 \{
00980   \textcolor{comment}{/* Check the parameters */}
00981   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00982   
00983   \textcolor{comment}{/* Return the selected ADC conversion value */}
00984   \textcolor{keywordflow}{return} (uint16\_t) ADCx->DR;
00985 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gaa12546e51ec905c90a3aada432bd4633}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Flag\+Status@{A\+D\+C\+\_\+\+Get\+Flag\+Status}}
\index{A\+D\+C\+\_\+\+Get\+Flag\+Status@{A\+D\+C\+\_\+\+Get\+Flag\+Status}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Flag\+Status()}
{\footnotesize\ttfamily \textbf{ Flag\+Status} A\+D\+C\+\_\+\+Get\+Flag\+Status (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+F\+L\+AG }\end{DoxyParamCaption})}



Checks whether the specified A\+DC flag is set or not. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+F\+L\+AG} & specifies the flag to check. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+A\+WD\+: Analog watchdog flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+E\+OC\+: End of conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+J\+E\+OC\+: End of injected group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+J\+S\+T\+RT\+: Start of injected group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+S\+T\+RT\+: Start of regular group conversion flag \item A\+D\+C\+\_\+\+F\+L\+A\+G\+\_\+\+O\+VR\+: Overrun flag \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & new state of A\+D\+C\+\_\+\+F\+L\+AG (S\+ET or R\+E\+S\+ET). \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1618} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ R\+E\+S\+ET}.


\begin{DoxyCode}
01619 \{
01620   FlagStatus bitstatus = RESET;
01621   \textcolor{comment}{/* Check the parameters */}
01622   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01623   assert_param(IS_ADC_GET_FLAG(ADC\_FLAG));
01624 
01625   \textcolor{comment}{/* Check the status of the specified ADC flag */}
01626   \textcolor{keywordflow}{if} ((ADCx->SR & ADC\_FLAG) != (uint8\_t)RESET)
01627   \{
01628     \textcolor{comment}{/* ADC\_FLAG is set */}
01629     bitstatus = SET;
01630   \}
01631   \textcolor{keywordflow}{else}
01632   \{
01633     \textcolor{comment}{/* ADC\_FLAG is reset */}
01634     bitstatus = RESET;
01635   \}
01636   \textcolor{comment}{/* Return the ADC\_FLAG status */}
01637   \textcolor{keywordflow}{return}  bitstatus;
01638 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga1dea5ed24571a2e0ce4cbd41c9c1ec46}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value}}
\index{A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value()}
{\footnotesize\ttfamily uint16\+\_\+t A\+D\+C\+\_\+\+Get\+Injected\+Conversion\+Value (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Injected\+Channel }\end{DoxyParamCaption})}



Returns the A\+DC injected channel conversion result. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Injected\+Channel} & the converted A\+DC injected channel. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+1\+: Injected Channel1 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+2\+: Injected Channel2 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+3\+: Injected Channel3 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+4\+: Injected Channel4 selected \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & Data conversion value. \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1473} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01474 \{
01475   \_\_IO uint32\_t tmp = 0;
01476   
01477   \textcolor{comment}{/* Check the parameters */}
01478   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01479   assert_param(IS_ADC_INJECTED_CHANNEL(ADC\_InjectedChannel));
01480 
01481   tmp = (uint32\_t)ADCx;
01482   tmp += ADC\_InjectedChannel + JDR_OFFSET;
01483   
01484   \textcolor{comment}{/* Returns the selected injected channel conversion data value */}
01485   \textcolor{keywordflow}{return} (uint16\_t) (*(\_\_IO uint32\_t*)  tmp); 
01486 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gaa1d3b910a83dbf14d4f68c8eef058612}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+I\+T\+Status@{A\+D\+C\+\_\+\+Get\+I\+T\+Status}}
\index{A\+D\+C\+\_\+\+Get\+I\+T\+Status@{A\+D\+C\+\_\+\+Get\+I\+T\+Status}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+I\+T\+Status()}
{\footnotesize\ttfamily \textbf{ I\+T\+Status} A\+D\+C\+\_\+\+Get\+I\+T\+Status (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint16\+\_\+t}]{A\+D\+C\+\_\+\+IT }\end{DoxyParamCaption})}



Checks whether the specified A\+DC interrupt has occurred or not. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+IT} & specifies the A\+DC interrupt source to check. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+I\+T\+\_\+\+E\+OC\+: End of conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+A\+WD\+: Analog watchdog interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+J\+E\+OC\+: End of injected conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+O\+VR\+: Overrun interrupt mask \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & new state of A\+D\+C\+\_\+\+IT (S\+ET or R\+E\+S\+ET). \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1674} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ R\+E\+S\+ET}.


\begin{DoxyCode}
01675 \{
01676   ITStatus bitstatus = RESET;
01677   uint32\_t itmask = 0, enablestatus = 0;
01678 
01679   \textcolor{comment}{/* Check the parameters */}
01680   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01681   assert_param(IS_ADC_IT(ADC\_IT));
01682 
01683   \textcolor{comment}{/* Get the ADC IT index */}
01684   itmask = ADC\_IT >> 8;
01685 
01686   \textcolor{comment}{/* Get the ADC\_IT enable bit status */}
01687   enablestatus = (ADCx->CR1 & ((uint32\_t)0x01 << (uint8\_t)ADC\_IT)) ;
01688 
01689   \textcolor{comment}{/* Check the status of the specified ADC interrupt */}
01690   \textcolor{keywordflow}{if} (((ADCx->SR & itmask) != (uint32\_t)RESET) && enablestatus)
01691   \{
01692     \textcolor{comment}{/* ADC\_IT is set */}
01693     bitstatus = SET;
01694   \}
01695   \textcolor{keywordflow}{else}
01696   \{
01697     \textcolor{comment}{/* ADC\_IT is reset */}
01698     bitstatus = RESET;
01699   \}
01700   \textcolor{comment}{/* Return the ADC\_IT status */}
01701   \textcolor{keywordflow}{return}  bitstatus;
01702 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga989f4365b56be99999b8ec096aba2081}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value}}
\index{A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value@{A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value()}
{\footnotesize\ttfamily uint32\+\_\+t A\+D\+C\+\_\+\+Get\+Multi\+Mode\+Conversion\+Value (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Returns the last A\+D\+C1, A\+D\+C2 and A\+D\+C3 regular conversions results data in the selected multi mode. 


\begin{DoxyParams}{Parameters}
{\em None} & \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & Data conversion value. \\
\hline
\end{DoxyRetVals}
\begin{DoxyNote}{Note}
In dual mode, the value returned by this function is as following Data[15\+:0] \+: these bits contain the regular data of A\+D\+C1. Data[31\+:16]\+: these bits contain the regular data of A\+D\+C2. 

In triple mode, the value returned by this function is as following Data[15\+:0] \+: these bits contain alternatively the regular data of A\+D\+C1, A\+D\+C3 and A\+D\+C2. Data[31\+:16]\+: these bits contain alternatively the regular data of A\+D\+C2, A\+D\+C1 and A\+D\+C3. 
\end{DoxyNote}


Definition at line \textbf{ 999} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01000 \{
01001   \textcolor{comment}{/* Return the multi mode conversion value */}
01002   \textcolor{keywordflow}{return} (*(\_\_IO uint32\_t *) CDR_ADDRESS);
01003 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gaf1119583782ecbcec380efcb7eb74883}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status@{A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status}}
\index{A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status@{A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status()}
{\footnotesize\ttfamily \textbf{ Flag\+Status} A\+D\+C\+\_\+\+Get\+Software\+Start\+Conv\+Status (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx }\end{DoxyParamCaption})}



Gets the selected A\+DC Software start regular conversion Status. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & new state of A\+DC software start conversion (S\+ET or R\+E\+S\+ET). \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 842} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ R\+E\+S\+ET}.


\begin{DoxyCode}
00843 \{
00844   FlagStatus bitstatus = RESET;
00845   \textcolor{comment}{/* Check the parameters */}
00846   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00847   
00848   \textcolor{comment}{/* Check the status of SWSTART bit */}
00849   \textcolor{keywordflow}{if} ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32\_t)RESET)
00850   \{
00851     \textcolor{comment}{/* SWSTART bit is set */}
00852     bitstatus = SET;
00853   \}
00854   \textcolor{keywordflow}{else}
00855   \{
00856     \textcolor{comment}{/* SWSTART bit is reset */}
00857     bitstatus = RESET;
00858   \}
00859   
00860   \textcolor{comment}{/* Return the SWSTART bit status */}
00861   \textcolor{keywordflow}{return}  bitstatus;
00862 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga8765f8835b8cfed13dce3d8d71767dcc}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status@{A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status}}
\index{A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status@{A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status()}
{\footnotesize\ttfamily \textbf{ Flag\+Status} A\+D\+C\+\_\+\+Get\+Software\+Start\+Injected\+Conv\+Cmd\+Status (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx }\end{DoxyParamCaption})}



Gets the selected A\+DC Software start injected conversion Status. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em The} & new state of A\+DC software start injected conversion (S\+ET or R\+E\+S\+ET). \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1390} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ R\+E\+S\+ET}.


\begin{DoxyCode}
01391 \{
01392   FlagStatus bitstatus = RESET;
01393   \textcolor{comment}{/* Check the parameters */}
01394   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01395   
01396   \textcolor{comment}{/* Check the status of JSWSTART bit */}
01397   \textcolor{keywordflow}{if} ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32\_t)RESET)
01398   \{
01399     \textcolor{comment}{/* JSWSTART bit is set */}
01400     bitstatus = SET;
01401   \}
01402   \textcolor{keywordflow}{else}
01403   \{
01404     \textcolor{comment}{/* JSWSTART bit is reset */}
01405     bitstatus = RESET;
01406   \}
01407   \textcolor{comment}{/* Return the JSWSTART bit status */}
01408   \textcolor{keywordflow}{return}  bitstatus;
01409 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gabbab6038cf8691404350625e477254f9}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Init@{A\+D\+C\+\_\+\+Init}}
\index{A\+D\+C\+\_\+\+Init@{A\+D\+C\+\_\+\+Init}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Init()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Init (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def} $\ast$}]{A\+D\+C\+\_\+\+Init\+Struct }\end{DoxyParamCaption})}



Initializes the A\+D\+Cx peripheral according to the specified parameters in the A\+D\+C\+\_\+\+Init\+Struct. 

\begin{DoxyNote}{Note}
This function is used to configure the global features of the A\+DC ( Resolution and Data Alignment), however, the rest of the configuration parameters are specific to the regular channels group (scan mode activation, continuous mode activation, External trigger source and edge, number of conversion in the regular channels group sequencer). 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Init\+Struct} & pointer to an \doxyref{A\+D\+C\+\_\+\+Init\+Type\+Def}{p.}{structADC__InitTypeDef} structure that contains the configuration information for the specified A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 228} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Continuous\+Conv\+Mode}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Data\+Align}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+External\+Trig\+Conv}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+External\+Trig\+Conv\+Edge}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Nbr\+Of\+Conversion}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Resolution}, and \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Scan\+Conv\+Mode}.


\begin{DoxyCode}
00229 \{
00230   uint32\_t tmpreg1 = 0;
00231   uint8\_t tmpreg2 = 0;
00232   \textcolor{comment}{/* Check the parameters */}
00233   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00234   assert_param(IS_ADC_RESOLUTION(ADC\_InitStruct->ADC_Resolution)); 
00235   assert_param(IS_FUNCTIONAL_STATE(ADC\_InitStruct->ADC_ScanConvMode));
00236   assert_param(IS_FUNCTIONAL_STATE(ADC\_InitStruct->ADC_ContinuousConvMode)); 
00237   assert_param(IS_ADC_EXT_TRIG_EDGE(ADC\_InitStruct->ADC_ExternalTrigConvEdge)); 
00238   assert_param(IS_ADC_EXT_TRIG(ADC\_InitStruct->ADC_ExternalTrigConv));    
00239   assert_param(IS_ADC_DATA_ALIGN(ADC\_InitStruct->ADC_DataAlign)); 
00240   assert_param(IS_ADC_REGULAR_LENGTH(ADC\_InitStruct->ADC_NbrOfConversion));
00241   
00242   \textcolor{comment}{/*---------------------------- ADCx CR1 Configuration -----------------*/}
00243   \textcolor{comment}{/* Get the ADCx CR1 value */}
00244   tmpreg1 = ADCx->CR1;
00245   
00246   \textcolor{comment}{/* Clear RES and SCAN bits */}
00247   tmpreg1 &= CR1_CLEAR_MASK;
00248   
00249   \textcolor{comment}{/* Configure ADCx: scan conversion mode and resolution */}
00250   \textcolor{comment}{/* Set SCAN bit according to ADC\_ScanConvMode value */}
00251   \textcolor{comment}{/* Set RES bit according to ADC\_Resolution value */} 
00252   tmpreg1 |= (uint32\_t)(((uint32\_t)ADC\_InitStruct->ADC_ScanConvMode << 8) | \(\backslash\)
00253                                    ADC\_InitStruct->ADC\_Resolution);
00254   \textcolor{comment}{/* Write to ADCx CR1 */}
00255   ADCx->CR1 = tmpreg1;
00256   \textcolor{comment}{/*---------------------------- ADCx CR2 Configuration -----------------*/}
00257   \textcolor{comment}{/* Get the ADCx CR2 value */}
00258   tmpreg1 = ADCx->CR2;
00259   
00260   \textcolor{comment}{/* Clear CONT, ALIGN, EXTEN and EXTSEL bits */}
00261   tmpreg1 &= CR2_CLEAR_MASK;
00262   
00263   \textcolor{comment}{/* Configure ADCx: external trigger event and edge, data alignment and }
00264 \textcolor{comment}{     continuous conversion mode */}
00265   \textcolor{comment}{/* Set ALIGN bit according to ADC\_DataAlign value */}
00266   \textcolor{comment}{/* Set EXTEN bits according to ADC\_ExternalTrigConvEdge value */} 
00267   \textcolor{comment}{/* Set EXTSEL bits according to ADC\_ExternalTrigConv value */}
00268   \textcolor{comment}{/* Set CONT bit according to ADC\_ContinuousConvMode value */}
00269   tmpreg1 |= (uint32\_t)(ADC\_InitStruct->ADC_DataAlign | \(\backslash\)
00270                         ADC\_InitStruct->ADC_ExternalTrigConv | 
00271                         ADC\_InitStruct->ADC_ExternalTrigConvEdge | \(\backslash\)
00272                         ((uint32\_t)ADC\_InitStruct->ADC_ContinuousConvMode << 1));
00273                         
00274   \textcolor{comment}{/* Write to ADCx CR2 */}
00275   ADCx->CR2 = tmpreg1;
00276   \textcolor{comment}{/*---------------------------- ADCx SQR1 Configuration -----------------*/}
00277   \textcolor{comment}{/* Get the ADCx SQR1 value */}
00278   tmpreg1 = ADCx->SQR1;
00279   
00280   \textcolor{comment}{/* Clear L bits */}
00281   tmpreg1 &= SQR1_L_RESET;
00282   
00283   \textcolor{comment}{/* Configure ADCx: regular channel sequence length */}
00284   \textcolor{comment}{/* Set L bits according to ADC\_NbrOfConversion value */}
00285   tmpreg2 |= (uint8\_t)(ADC\_InitStruct->ADC_NbrOfConversion - (uint8\_t)1);
00286   tmpreg1 |= ((uint32\_t)tmpreg2 << 20);
00287   
00288   \textcolor{comment}{/* Write to ADCx SQR1 */}
00289   ADCx->SQR1 = tmpreg1;
00290 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gae2b44bff080184e1cf6f2cb6b9bb3e59}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Injected\+Channel\+Config@{A\+D\+C\+\_\+\+Injected\+Channel\+Config}}
\index{A\+D\+C\+\_\+\+Injected\+Channel\+Config@{A\+D\+C\+\_\+\+Injected\+Channel\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Injected\+Channel\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Injected\+Channel\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Channel,  }\item[{uint8\+\_\+t}]{Rank,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Sample\+Time }\end{DoxyParamCaption})}



Configures for the selected A\+DC injected channel its corresponding rank in the sequencer and its sample time. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Channel} & the A\+DC channel to configure. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Channel\+\_\+0\+: A\+DC Channel0 selected \item A\+D\+C\+\_\+\+Channel\+\_\+1\+: A\+DC Channel1 selected \item A\+D\+C\+\_\+\+Channel\+\_\+2\+: A\+DC Channel2 selected \item A\+D\+C\+\_\+\+Channel\+\_\+3\+: A\+DC Channel3 selected \item A\+D\+C\+\_\+\+Channel\+\_\+4\+: A\+DC Channel4 selected \item A\+D\+C\+\_\+\+Channel\+\_\+5\+: A\+DC Channel5 selected \item A\+D\+C\+\_\+\+Channel\+\_\+6\+: A\+DC Channel6 selected \item A\+D\+C\+\_\+\+Channel\+\_\+7\+: A\+DC Channel7 selected \item A\+D\+C\+\_\+\+Channel\+\_\+8\+: A\+DC Channel8 selected \item A\+D\+C\+\_\+\+Channel\+\_\+9\+: A\+DC Channel9 selected \item A\+D\+C\+\_\+\+Channel\+\_\+10\+: A\+DC Channel10 selected \item A\+D\+C\+\_\+\+Channel\+\_\+11\+: A\+DC Channel11 selected \item A\+D\+C\+\_\+\+Channel\+\_\+12\+: A\+DC Channel12 selected \item A\+D\+C\+\_\+\+Channel\+\_\+13\+: A\+DC Channel13 selected \item A\+D\+C\+\_\+\+Channel\+\_\+14\+: A\+DC Channel14 selected \item A\+D\+C\+\_\+\+Channel\+\_\+15\+: A\+DC Channel15 selected \item A\+D\+C\+\_\+\+Channel\+\_\+16\+: A\+DC Channel16 selected \item A\+D\+C\+\_\+\+Channel\+\_\+17\+: A\+DC Channel17 selected \item A\+D\+C\+\_\+\+Channel\+\_\+18\+: A\+DC Channel18 selected \end{DoxyItemize}
\\
\hline
{\em Rank} & The rank in the injected group sequencer. This parameter must be between 1 to 4. \\
\hline
{\em A\+D\+C\+\_\+\+Sample\+Time} & The sample time value to be set for the selected channel. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Sample\+Time\+\_\+3\+Cycles\+: Sample time equal to 3 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+15\+Cycles\+: Sample time equal to 15 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+28\+Cycles\+: Sample time equal to 28 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+56\+Cycles\+: Sample time equal to 56 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+84\+Cycles\+: Sample time equal to 84 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+112\+Cycles\+: Sample time equal to 112 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+144\+Cycles\+: Sample time equal to 144 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+480\+Cycles\+: Sample time equal to 480 cycles \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1186} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01187 \{
01188   uint32\_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
01189   \textcolor{comment}{/* Check the parameters */}
01190   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01191   assert_param(IS_ADC_CHANNEL(ADC\_Channel));
01192   assert_param(IS_ADC_INJECTED_RANK(Rank));
01193   assert_param(IS_ADC_SAMPLE_TIME(ADC\_SampleTime));
01194   \textcolor{comment}{/* if ADC\_Channel\_10 ... ADC\_Channel\_18 is selected */}
01195   \textcolor{keywordflow}{if} (ADC\_Channel > ADC_Channel_9)
01196   \{
01197     \textcolor{comment}{/* Get the old register value */}
01198     tmpreg1 = ADCx->SMPR1;
01199     \textcolor{comment}{/* Calculate the mask to clear */}
01200     tmpreg2 = SMPR1_SMP_SET << (3*(ADC\_Channel - 10));
01201     \textcolor{comment}{/* Clear the old sample time */}
01202     tmpreg1 &= ~tmpreg2;
01203     \textcolor{comment}{/* Calculate the mask to set */}
01204     tmpreg2 = (uint32\_t)ADC\_SampleTime << (3*(ADC\_Channel - 10));
01205     \textcolor{comment}{/* Set the new sample time */}
01206     tmpreg1 |= tmpreg2;
01207     \textcolor{comment}{/* Store the new register value */}
01208     ADCx->SMPR1 = tmpreg1;
01209   \}
01210   \textcolor{keywordflow}{else} \textcolor{comment}{/* ADC\_Channel include in ADC\_Channel\_[0..9] */}
01211   \{
01212     \textcolor{comment}{/* Get the old register value */}
01213     tmpreg1 = ADCx->SMPR2;
01214     \textcolor{comment}{/* Calculate the mask to clear */}
01215     tmpreg2 = SMPR2_SMP_SET << (3 * ADC\_Channel);
01216     \textcolor{comment}{/* Clear the old sample time */}
01217     tmpreg1 &= ~tmpreg2;
01218     \textcolor{comment}{/* Calculate the mask to set */}
01219     tmpreg2 = (uint32\_t)ADC\_SampleTime << (3 * ADC\_Channel);
01220     \textcolor{comment}{/* Set the new sample time */}
01221     tmpreg1 |= tmpreg2;
01222     \textcolor{comment}{/* Store the new register value */}
01223     ADCx->SMPR2 = tmpreg1;
01224   \}
01225   \textcolor{comment}{/* Rank configuration */}
01226   \textcolor{comment}{/* Get the old register value */}
01227   tmpreg1 = ADCx->JSQR;
01228   \textcolor{comment}{/* Get JL value: Number = JL+1 */}
01229   tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
01230   \textcolor{comment}{/* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */}
01231   tmpreg2 = JSQR_JSQ_SET << (5 * (uint8\_t)((Rank + 3) - (tmpreg3 + 1)));
01232   \textcolor{comment}{/* Clear the old JSQx bits for the selected rank */}
01233   tmpreg1 &= ~tmpreg2;
01234   \textcolor{comment}{/* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */}
01235   tmpreg2 = (uint32\_t)ADC\_Channel << (5 * (uint8\_t)((Rank + 3) - (tmpreg3 + 1)));
01236   \textcolor{comment}{/* Set the JSQx bits for the selected rank */}
01237   tmpreg1 |= tmpreg2;
01238   \textcolor{comment}{/* Store the new register value */}
01239   ADCx->JSQR = tmpreg1;
01240 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga0b583b94183fa4ff287177b9ee808092}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd@{A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd}}
\index{A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd@{A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Injected\+Disc\+Mode\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the discontinuous mode for injected group channel for the specified A\+DC. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em New\+State} & new state of the selected A\+DC discontinuous mode on injected group channel. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1445} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01446 \{
01447   \textcolor{comment}{/* Check the parameters */}
01448   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01449   assert_param(IS_FUNCTIONAL_STATE(NewState));
01450   \textcolor{keywordflow}{if} (NewState != DISABLE)
01451   \{
01452     \textcolor{comment}{/* Enable the selected ADC injected discontinuous mode */}
01453     ADCx->CR1 |= (uint32\_t)ADC_CR1_JDISCEN;
01454   \}
01455   \textcolor{keywordflow}{else}
01456   \{
01457     \textcolor{comment}{/* Disable the selected ADC injected discontinuous mode */}
01458     ADCx->CR1 &= (uint32\_t)(~ADC_CR1_JDISCEN);
01459   \}
01460 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga24eba90bc3ee955e07659a605011710d}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config@{A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config}}
\index{A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config@{A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Injected\+Sequencer\+Length\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{Length }\end{DoxyParamCaption})}



Configures the sequencer length for injected channels. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em Length} & The sequencer length. This parameter must be a number between 1 to 4. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1249} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01250 \{
01251   uint32\_t tmpreg1 = 0;
01252   uint32\_t tmpreg2 = 0;
01253   \textcolor{comment}{/* Check the parameters */}
01254   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01255   assert_param(IS_ADC_INJECTED_LENGTH(Length));
01256   
01257   \textcolor{comment}{/* Get the old register value */}
01258   tmpreg1 = ADCx->JSQR;
01259   
01260   \textcolor{comment}{/* Clear the old injected sequence length JL bits */}
01261   tmpreg1 &= JSQR_JL_RESET;
01262   
01263   \textcolor{comment}{/* Set the injected sequence length JL bits */}
01264   tmpreg2 = Length - 1; 
01265   tmpreg1 |= tmpreg2 << 20;
01266   
01267   \textcolor{comment}{/* Store the new register value */}
01268   ADCx->JSQR = tmpreg1;
01269 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gad4c84b54b539944f555488bf979f82b6}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+I\+T\+Config@{A\+D\+C\+\_\+\+I\+T\+Config}}
\index{A\+D\+C\+\_\+\+I\+T\+Config@{A\+D\+C\+\_\+\+I\+T\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+I\+T\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+I\+T\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint16\+\_\+t}]{A\+D\+C\+\_\+\+IT,  }\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the specified A\+DC interrupts. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+IT} & specifies the A\+DC interrupt sources to be enabled or disabled. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+I\+T\+\_\+\+E\+OC\+: End of conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+A\+WD\+: Analog watchdog interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+J\+E\+OC\+: End of injected conversion interrupt mask \item A\+D\+C\+\_\+\+I\+T\+\_\+\+O\+VR\+: Overrun interrupt enable \end{DoxyItemize}
\\
\hline
{\em New\+State} & new state of the specified A\+DC interrupts. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1581} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01582 \{
01583   uint32\_t itmask = 0;
01584   \textcolor{comment}{/* Check the parameters */}
01585   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01586   assert_param(IS_FUNCTIONAL_STATE(NewState));
01587   assert_param(IS_ADC_IT(ADC\_IT)); 
01588 
01589   \textcolor{comment}{/* Get the ADC IT index */}
01590   itmask = (uint8\_t)ADC\_IT;
01591   itmask = (uint32\_t)0x01 << itmask;    
01592 
01593   \textcolor{keywordflow}{if} (NewState != DISABLE)
01594   \{
01595     \textcolor{comment}{/* Enable the selected ADC interrupts */}
01596     ADCx->CR1 |= itmask;
01597   \}
01598   \textcolor{keywordflow}{else}
01599   \{
01600     \textcolor{comment}{/* Disable the selected ADC interrupts */}
01601     ADCx->CR1 &= (~(uint32\_t)itmask);
01602   \}
01603 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga40f2be2edf2a33fc15f4a5933b562970}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd@{A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd}}
\index{A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd@{A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Multi\+Mode\+D\+M\+A\+Request\+After\+Last\+Transfer\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the A\+DC D\+MA request after last transfer in multi A\+DC mode. 


\begin{DoxyParams}{Parameters}
{\em New\+State} & new state of the selected A\+DC D\+MA request after last transfer. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
if Enabled, D\+MA requests are issued as long as data are converted and D\+MA mode for multi A\+DC mode (selected using \doxyref{A\+D\+C\+\_\+\+Common\+Init()}{p.}{group__ADC__Group1_ga5803f6581a9cd7e90b6e637067102d94} function by A\+D\+C\+\_\+\+Common\+Init\+Struct.\+A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode structure member) is A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode\+\_\+1, A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode\+\_\+2 or A\+D\+C\+\_\+\+D\+M\+A\+Access\+Mode\+\_\+3. 
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1099} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
01100 \{
01101   \textcolor{comment}{/* Check the parameters */}
01102   assert_param(IS_FUNCTIONAL_STATE(NewState));
01103   \textcolor{keywordflow}{if} (NewState != DISABLE)
01104   \{
01105     \textcolor{comment}{/* Enable the selected ADC DMA request after last transfer */}
01106     ADC->CCR |= (uint32\_t)ADC_CCR_DDS;
01107   \}
01108   \textcolor{keywordflow}{else}
01109   \{
01110     \textcolor{comment}{/* Disable the selected ADC DMA request after last transfer */}
01111     ADC->CCR &= (uint32\_t)(~ADC_CCR_DDS);
01112   \}
01113 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gac531adb577b648d4bb8881f2ed627d52}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Regular\+Channel\+Config@{A\+D\+C\+\_\+\+Regular\+Channel\+Config}}
\index{A\+D\+C\+\_\+\+Regular\+Channel\+Config@{A\+D\+C\+\_\+\+Regular\+Channel\+Config}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Regular\+Channel\+Config()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Regular\+Channel\+Config (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Channel,  }\item[{uint8\+\_\+t}]{Rank,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Sample\+Time }\end{DoxyParamCaption})}



Configures for the selected A\+DC regular channel its corresponding rank in the sequencer and its sample time. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Channel} & the A\+DC channel to configure. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Channel\+\_\+0\+: A\+DC Channel0 selected \item A\+D\+C\+\_\+\+Channel\+\_\+1\+: A\+DC Channel1 selected \item A\+D\+C\+\_\+\+Channel\+\_\+2\+: A\+DC Channel2 selected \item A\+D\+C\+\_\+\+Channel\+\_\+3\+: A\+DC Channel3 selected \item A\+D\+C\+\_\+\+Channel\+\_\+4\+: A\+DC Channel4 selected \item A\+D\+C\+\_\+\+Channel\+\_\+5\+: A\+DC Channel5 selected \item A\+D\+C\+\_\+\+Channel\+\_\+6\+: A\+DC Channel6 selected \item A\+D\+C\+\_\+\+Channel\+\_\+7\+: A\+DC Channel7 selected \item A\+D\+C\+\_\+\+Channel\+\_\+8\+: A\+DC Channel8 selected \item A\+D\+C\+\_\+\+Channel\+\_\+9\+: A\+DC Channel9 selected \item A\+D\+C\+\_\+\+Channel\+\_\+10\+: A\+DC Channel10 selected \item A\+D\+C\+\_\+\+Channel\+\_\+11\+: A\+DC Channel11 selected \item A\+D\+C\+\_\+\+Channel\+\_\+12\+: A\+DC Channel12 selected \item A\+D\+C\+\_\+\+Channel\+\_\+13\+: A\+DC Channel13 selected \item A\+D\+C\+\_\+\+Channel\+\_\+14\+: A\+DC Channel14 selected \item A\+D\+C\+\_\+\+Channel\+\_\+15\+: A\+DC Channel15 selected \item A\+D\+C\+\_\+\+Channel\+\_\+16\+: A\+DC Channel16 selected \item A\+D\+C\+\_\+\+Channel\+\_\+17\+: A\+DC Channel17 selected \item A\+D\+C\+\_\+\+Channel\+\_\+18\+: A\+DC Channel18 selected \end{DoxyItemize}
\\
\hline
{\em Rank} & The rank in the regular group sequencer. This parameter must be between 1 to 16. \\
\hline
{\em A\+D\+C\+\_\+\+Sample\+Time} & The sample time value to be set for the selected channel. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Sample\+Time\+\_\+3\+Cycles\+: Sample time equal to 3 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+15\+Cycles\+: Sample time equal to 15 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+28\+Cycles\+: Sample time equal to 28 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+56\+Cycles\+: Sample time equal to 56 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+84\+Cycles\+: Sample time equal to 84 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+112\+Cycles\+: Sample time equal to 112 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+144\+Cycles\+: Sample time equal to 144 cycles \item A\+D\+C\+\_\+\+Sample\+Time\+\_\+480\+Cycles\+: Sample time equal to 480 cycles \end{DoxyItemize}
\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 708} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00709 \{
00710   uint32\_t tmpreg1 = 0, tmpreg2 = 0;
00711   \textcolor{comment}{/* Check the parameters */}
00712   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00713   assert_param(IS_ADC_CHANNEL(ADC\_Channel));
00714   assert_param(IS_ADC_REGULAR_RANK(Rank));
00715   assert_param(IS_ADC_SAMPLE_TIME(ADC\_SampleTime));
00716   
00717   \textcolor{comment}{/* if ADC\_Channel\_10 ... ADC\_Channel\_18 is selected */}
00718   \textcolor{keywordflow}{if} (ADC\_Channel > ADC_Channel_9)
00719   \{
00720     \textcolor{comment}{/* Get the old register value */}
00721     tmpreg1 = ADCx->SMPR1;
00722     
00723     \textcolor{comment}{/* Calculate the mask to clear */}
00724     tmpreg2 = SMPR1_SMP_SET << (3 * (ADC\_Channel - 10));
00725     
00726     \textcolor{comment}{/* Clear the old sample time */}
00727     tmpreg1 &= ~tmpreg2;
00728     
00729     \textcolor{comment}{/* Calculate the mask to set */}
00730     tmpreg2 = (uint32\_t)ADC\_SampleTime << (3 * (ADC\_Channel - 10));
00731     
00732     \textcolor{comment}{/* Set the new sample time */}
00733     tmpreg1 |= tmpreg2;
00734     
00735     \textcolor{comment}{/* Store the new register value */}
00736     ADCx->SMPR1 = tmpreg1;
00737   \}
00738   \textcolor{keywordflow}{else} \textcolor{comment}{/* ADC\_Channel include in ADC\_Channel\_[0..9] */}
00739   \{
00740     \textcolor{comment}{/* Get the old register value */}
00741     tmpreg1 = ADCx->SMPR2;
00742     
00743     \textcolor{comment}{/* Calculate the mask to clear */}
00744     tmpreg2 = SMPR2_SMP_SET << (3 * ADC\_Channel);
00745     
00746     \textcolor{comment}{/* Clear the old sample time */}
00747     tmpreg1 &= ~tmpreg2;
00748     
00749     \textcolor{comment}{/* Calculate the mask to set */}
00750     tmpreg2 = (uint32\_t)ADC\_SampleTime << (3 * ADC\_Channel);
00751     
00752     \textcolor{comment}{/* Set the new sample time */}
00753     tmpreg1 |= tmpreg2;
00754     
00755     \textcolor{comment}{/* Store the new register value */}
00756     ADCx->SMPR2 = tmpreg1;
00757   \}
00758   \textcolor{comment}{/* For Rank 1 to 6 */}
00759   \textcolor{keywordflow}{if} (Rank < 7)
00760   \{
00761     \textcolor{comment}{/* Get the old register value */}
00762     tmpreg1 = ADCx->SQR3;
00763     
00764     \textcolor{comment}{/* Calculate the mask to clear */}
00765     tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
00766     
00767     \textcolor{comment}{/* Clear the old SQx bits for the selected rank */}
00768     tmpreg1 &= ~tmpreg2;
00769     
00770     \textcolor{comment}{/* Calculate the mask to set */}
00771     tmpreg2 = (uint32\_t)ADC\_Channel << (5 * (Rank - 1));
00772     
00773     \textcolor{comment}{/* Set the SQx bits for the selected rank */}
00774     tmpreg1 |= tmpreg2;
00775     
00776     \textcolor{comment}{/* Store the new register value */}
00777     ADCx->SQR3 = tmpreg1;
00778   \}
00779   \textcolor{comment}{/* For Rank 7 to 12 */}
00780   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Rank < 13)
00781   \{
00782     \textcolor{comment}{/* Get the old register value */}
00783     tmpreg1 = ADCx->SQR2;
00784     
00785     \textcolor{comment}{/* Calculate the mask to clear */}
00786     tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
00787     
00788     \textcolor{comment}{/* Clear the old SQx bits for the selected rank */}
00789     tmpreg1 &= ~tmpreg2;
00790     
00791     \textcolor{comment}{/* Calculate the mask to set */}
00792     tmpreg2 = (uint32\_t)ADC\_Channel << (5 * (Rank - 7));
00793     
00794     \textcolor{comment}{/* Set the SQx bits for the selected rank */}
00795     tmpreg1 |= tmpreg2;
00796     
00797     \textcolor{comment}{/* Store the new register value */}
00798     ADCx->SQR2 = tmpreg1;
00799   \}
00800   \textcolor{comment}{/* For Rank 13 to 16 */}
00801   \textcolor{keywordflow}{else}
00802   \{
00803     \textcolor{comment}{/* Get the old register value */}
00804     tmpreg1 = ADCx->SQR1;
00805     
00806     \textcolor{comment}{/* Calculate the mask to clear */}
00807     tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
00808     
00809     \textcolor{comment}{/* Clear the old SQx bits for the selected rank */}
00810     tmpreg1 &= ~tmpreg2;
00811     
00812     \textcolor{comment}{/* Calculate the mask to set */}
00813     tmpreg2 = (uint32\_t)ADC\_Channel << (5 * (Rank - 13));
00814     
00815     \textcolor{comment}{/* Set the SQx bits for the selected rank */}
00816     tmpreg1 |= tmpreg2;
00817     
00818     \textcolor{comment}{/* Store the new register value */}
00819     ADCx->SQR1 = tmpreg1;
00820   \}
00821 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga07a942613088ab3ecfc3d97a20475920}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Set\+Injected\+Offset@{A\+D\+C\+\_\+\+Set\+Injected\+Offset}}
\index{A\+D\+C\+\_\+\+Set\+Injected\+Offset@{A\+D\+C\+\_\+\+Set\+Injected\+Offset}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Set\+Injected\+Offset()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Set\+Injected\+Offset (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx,  }\item[{uint8\+\_\+t}]{A\+D\+C\+\_\+\+Injected\+Channel,  }\item[{uint16\+\_\+t}]{Offset }\end{DoxyParamCaption})}



Set the injected channels conversion value offset. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
{\em A\+D\+C\+\_\+\+Injected\+Channel} & the A\+DC injected channel to set its offset. This parameter can be one of the following values\+: \begin{DoxyItemize}
\item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+1\+: Injected Channel1 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+2\+: Injected Channel2 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+3\+: Injected Channel3 selected \item A\+D\+C\+\_\+\+Injected\+Channel\+\_\+4\+: Injected Channel4 selected \end{DoxyItemize}
\\
\hline
{\em Offset} & the offset value for the selected A\+DC injected channel This parameter must be a 12bit value. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1284} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01285 \{
01286     \_\_IO uint32\_t tmp = 0;
01287   \textcolor{comment}{/* Check the parameters */}
01288   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01289   assert_param(IS_ADC_INJECTED_CHANNEL(ADC\_InjectedChannel));
01290   assert_param(IS_ADC_OFFSET(Offset));
01291   
01292   tmp = (uint32\_t)ADCx;
01293   tmp += ADC\_InjectedChannel;
01294   
01295   \textcolor{comment}{/* Set the selected injected channel data offset */}
01296  *(\_\_IO uint32\_t *) tmp = (uint32\_t)Offset;
01297 \}
\end{DoxyCode}
\mbox{\label{group__ADC_gac1cd466e725595812c1bbfdad2459ff1}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Software\+Start\+Conv@{A\+D\+C\+\_\+\+Software\+Start\+Conv}}
\index{A\+D\+C\+\_\+\+Software\+Start\+Conv@{A\+D\+C\+\_\+\+Software\+Start\+Conv}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Software\+Start\+Conv()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Software\+Start\+Conv (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx }\end{DoxyParamCaption})}



Enables the selected A\+DC software start conversion of the regular channels. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 828} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
00829 \{
00830   \textcolor{comment}{/* Check the parameters */}
00831   assert_param(IS_ADC_ALL_PERIPH(ADCx));
00832   
00833   \textcolor{comment}{/* Enable the selected ADC conversion for regular group */}
00834   ADCx->CR2 |= (uint32\_t)ADC_CR2_SWSTART;
00835 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga79b2f6c3c77925b35495f2db228895de}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv@{A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv}}
\index{A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv@{A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Software\+Start\+Injected\+Conv (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Type\+Def} $\ast$}]{A\+D\+Cx }\end{DoxyParamCaption})}



Enables the selected A\+DC software start conversion of the injected channels. 


\begin{DoxyParams}{Parameters}
{\em A\+D\+Cx} & where x can be 1, 2 or 3 to select the A\+DC peripheral. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 1377} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.


\begin{DoxyCode}
01378 \{
01379   \textcolor{comment}{/* Check the parameters */}
01380   assert_param(IS_ADC_ALL_PERIPH(ADCx));
01381   \textcolor{comment}{/* Enable the selected ADC conversion for injected group */}
01382   ADCx->CR2 |= (uint32\_t)ADC_CR2_JSWSTART;
01383 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga6c6e754d1d0a98d56e465efaf73272ec}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Struct\+Init@{A\+D\+C\+\_\+\+Struct\+Init}}
\index{A\+D\+C\+\_\+\+Struct\+Init@{A\+D\+C\+\_\+\+Struct\+Init}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Struct\+Init()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Struct\+Init (\begin{DoxyParamCaption}\item[{\textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def} $\ast$}]{A\+D\+C\+\_\+\+Init\+Struct }\end{DoxyParamCaption})}



Fills each A\+D\+C\+\_\+\+Init\+Struct member with its default value. 

\begin{DoxyNote}{Note}
This function is used to initialize the global features of the A\+DC ( Resolution and Data Alignment), however, the rest of the configuration parameters are specific to the regular channels group (scan mode activation, continuous mode activation, External trigger source and edge, number of conversion in the regular channels group sequencer). 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em A\+D\+C\+\_\+\+Init\+Struct} & pointer to an \doxyref{A\+D\+C\+\_\+\+Init\+Type\+Def}{p.}{structADC__InitTypeDef} structure which will be initialized. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 303} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Continuous\+Conv\+Mode}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Data\+Align}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+External\+Trig\+Conv}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+External\+Trig\+Conv\+Edge}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Nbr\+Of\+Conversion}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Resolution}, \textbf{ A\+D\+C\+\_\+\+Init\+Type\+Def\+::\+A\+D\+C\+\_\+\+Scan\+Conv\+Mode}, and \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00304 \{
00305   \textcolor{comment}{/* Initialize the ADC\_Mode member */}
00306   ADC\_InitStruct->ADC_Resolution = ADC_Resolution_12b;
00307 
00308   \textcolor{comment}{/* initialize the ADC\_ScanConvMode member */}
00309   ADC\_InitStruct->ADC_ScanConvMode = DISABLE;
00310 
00311   \textcolor{comment}{/* Initialize the ADC\_ContinuousConvMode member */}
00312   ADC\_InitStruct->ADC_ContinuousConvMode = DISABLE;
00313 
00314   \textcolor{comment}{/* Initialize the ADC\_ExternalTrigConvEdge member */}
00315   ADC\_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
00316 
00317   \textcolor{comment}{/* Initialize the ADC\_ExternalTrigConv member */}
00318   ADC\_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
00319 
00320   \textcolor{comment}{/* Initialize the ADC\_DataAlign member */}
00321   ADC\_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00322 
00323   \textcolor{comment}{/* Initialize the ADC\_NbrOfConversion member */}
00324   ADC\_InitStruct->ADC_NbrOfConversion = 1;
00325 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga848682e2d7d3de9f8cf03ffa4c11f0b5}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd@{A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd}}
\index{A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd@{A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+Temp\+Sensor\+Vrefint\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the temperature sensor and Vrefint channels. 


\begin{DoxyParams}{Parameters}
{\em New\+State} & new state of the temperature sensor and Vrefint channels. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 585} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00586 \{
00587   \textcolor{comment}{/* Check the parameters */}
00588   assert_param(IS_FUNCTIONAL_STATE(NewState));
00589   \textcolor{keywordflow}{if} (NewState != DISABLE)
00590   \{
00591     \textcolor{comment}{/* Enable the temperature sensor and Vrefint channel*/}
00592     ADC->CCR |= (uint32\_t)ADC_CCR_TSVREFE;
00593   \}
00594   \textcolor{keywordflow}{else}
00595   \{
00596     \textcolor{comment}{/* Disable the temperature sensor and Vrefint channel*/}
00597     ADC->CCR &= (uint32\_t)(~ADC_CCR_TSVREFE);
00598   \}
00599 \}
\end{DoxyCode}
\mbox{\label{group__ADC_ga17fc58510ddc80024e65d9738ad6e98c}} 
\index{A\+DC@{A\+DC}!A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd@{A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd}}
\index{A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd@{A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd}!A\+DC@{A\+DC}}
\subsubsection{A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd()}
{\footnotesize\ttfamily void A\+D\+C\+\_\+\+V\+B\+A\+T\+Cmd (\begin{DoxyParamCaption}\item[{\textbf{ Functional\+State}}]{New\+State }\end{DoxyParamCaption})}



Enables or disables the V\+B\+AT (Voltage Battery) channel. 


\begin{DoxyParams}{Parameters}
{\em New\+State} & new state of the V\+B\+AT channel. This parameter can be\+: E\+N\+A\+B\+LE or D\+I\+S\+A\+B\+LE. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}


Definition at line \textbf{ 607} of file \textbf{ stm32f4xx\+\_\+adc.\+c}.



References \textbf{ D\+I\+S\+A\+B\+LE}.


\begin{DoxyCode}
00608 \{
00609   \textcolor{comment}{/* Check the parameters */}
00610   assert_param(IS_FUNCTIONAL_STATE(NewState));
00611   \textcolor{keywordflow}{if} (NewState != DISABLE)
00612   \{
00613     \textcolor{comment}{/* Enable the VBAT channel*/}
00614     ADC->CCR |= (uint32\_t)ADC_CCR_VBATE;
00615   \}
00616   \textcolor{keywordflow}{else}
00617   \{
00618     \textcolor{comment}{/* Disable the VBAT channel*/}
00619     ADC->CCR &= (uint32\_t)(~ADC_CCR_VBATE);
00620   \}
00621 \}
\end{DoxyCode}
