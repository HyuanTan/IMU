\section{stm32f4xx\+\_\+i2c.\+c}
\label{stm32f4xx__i2c_8c_source}\index{C\+:/\+Users/\+Md. Istiaq Mahbub/\+Desktop/\+I\+M\+U/\+M\+P\+U6050\+\_\+\+Motion\+Driver/\+S\+T\+M32\+F4xx\+\_\+\+Std\+Periph\+\_\+\+Driver/src/stm32f4xx\+\_\+i2c.\+c@{C\+:/\+Users/\+Md. Istiaq Mahbub/\+Desktop/\+I\+M\+U/\+M\+P\+U6050\+\_\+\+Motion\+Driver/\+S\+T\+M32\+F4xx\+\_\+\+Std\+Periph\+\_\+\+Driver/src/stm32f4xx\+\_\+i2c.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/**}
00002 \textcolor{comment}{  ******************************************************************************}
00003 \textcolor{comment}{  * @file    stm32f4xx\_i2c.c}
00004 \textcolor{comment}{  * @author  MCD Application Team}
00005 \textcolor{comment}{  * @version V1.0.0}
00006 \textcolor{comment}{  * @date    30-September-2011}
00007 \textcolor{comment}{  * @brief   This file provides firmware functions to manage the following }
00008 \textcolor{comment}{  *          functionalities of the Inter-integrated circuit (I2C)}
00009 \textcolor{comment}{  *           - Initialization and Configuration}
00010 \textcolor{comment}{  *           - Data transfers}
00011 \textcolor{comment}{  *           - PEC management}
00012 \textcolor{comment}{  *           - DMA transfers management}
00013 \textcolor{comment}{  *           - Interrupts, events and flags management }
00014 \textcolor{comment}{  *           }
00015 \textcolor{comment}{  *  @verbatim}
00016 \textcolor{comment}{  *    }
00017 \textcolor{comment}{  *          ===================================================================}
00018 \textcolor{comment}{  *                                 How to use this driver}
00019 \textcolor{comment}{  *          ===================================================================}
00020 \textcolor{comment}{  *          1. Enable peripheral clock using RCC\_APB1PeriphClockCmd(RCC\_APB1Periph\_I2Cx, ENABLE)}
00021 \textcolor{comment}{  *             function for I2C1, I2C2 or I2C3.}
00022 \textcolor{comment}{  *}
00023 \textcolor{comment}{  *          2. Enable SDA, SCL  and SMBA (when used) GPIO clocks using }
00024 \textcolor{comment}{  *             RCC\_AHBPeriphClockCmd() function. }
00025 \textcolor{comment}{  *}
00026 \textcolor{comment}{  *          3. Peripherals alternate function: }
00027 \textcolor{comment}{  *                 - Connect the pin to the desired peripherals' Alternate }
00028 \textcolor{comment}{  *                   Function (AF) using GPIO\_PinAFConfig() function}
00029 \textcolor{comment}{  *                 - Configure the desired pin in alternate function by:}
00030 \textcolor{comment}{  *                   GPIO\_InitStruct->GPIO\_Mode = GPIO\_Mode\_AF}
00031 \textcolor{comment}{  *                 - Select the type, pull-up/pull-down and output speed via }
00032 \textcolor{comment}{  *                   GPIO\_PuPd, GPIO\_OType and GPIO\_Speed members}
00033 \textcolor{comment}{  *                 - Call GPIO\_Init() function}
00034 \textcolor{comment}{  *                 Recommended configuration is Push-Pull, Pull-up, Open-Drain.}
00035 \textcolor{comment}{  *                 Add an external pull up if necessary (typically 4.7 KOhm).      }
00036 \textcolor{comment}{  *        }
00037 \textcolor{comment}{  *          4. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged}
00038 \textcolor{comment}{  *             Address using the I2C\_Init() function.}
00039 \textcolor{comment}{  *}
00040 \textcolor{comment}{  *          5. Optionally you can enable/configure the following parameters without}
00041 \textcolor{comment}{  *             re-initialization (i.e there is no need to call again I2C\_Init() function):}
00042 \textcolor{comment}{  *              - Enable the acknowledge feature using I2C\_AcknowledgeConfig() function}
00043 \textcolor{comment}{  *              - Enable the dual addressing mode using I2C\_DualAddressCmd() function}
00044 \textcolor{comment}{  *              - Enable the general call using the I2C\_GeneralCallCmd() function}
00045 \textcolor{comment}{  *              - Enable the clock stretching using I2C\_StretchClockCmd() function}
00046 \textcolor{comment}{  *              - Enable the fast mode duty cycle using the I2C\_FastModeDutyCycleConfig()}
00047 \textcolor{comment}{  *                function.}
00048 \textcolor{comment}{  *              - Configure the NACK position for Master Receiver mode in case of }
00049 \textcolor{comment}{  *                2 bytes reception using the function I2C\_NACKPositionConfig().  }
00050 \textcolor{comment}{  *              - Enable the PEC Calculation using I2C\_CalculatePEC() function}
00051 \textcolor{comment}{  *              - For SMBus Mode: }
00052 \textcolor{comment}{  *                   - Enable the Address Resolution Protocol (ARP) using I2C\_ARPCmd() function}
00053 \textcolor{comment}{  *                   - Configure the SMBusAlert pin using I2C\_SMBusAlertConfig() function}
00054 \textcolor{comment}{  *}
00055 \textcolor{comment}{  *          6. Enable the NVIC and the corresponding interrupt using the function }
00056 \textcolor{comment}{  *             I2C\_ITConfig() if you need to use interrupt mode. }
00057 \textcolor{comment}{  *}
00058 \textcolor{comment}{  *          7. When using the DMA mode }
00059 \textcolor{comment}{  *                   - Configure the DMA using DMA\_Init() function}
00060 \textcolor{comment}{  *                   - Active the needed channel Request using I2C\_DMACmd() or}
00061 \textcolor{comment}{  *                     I2C\_DMALastTransferCmd() function.}
00062 \textcolor{comment}{  *              @note When using DMA mode, I2C interrupts may be used at the same time to}
00063 \textcolor{comment}{  *                    control the communication flow (Start/Stop/Ack... events and errors).}
00064 \textcolor{comment}{  * }
00065 \textcolor{comment}{  *          8. Enable the I2C using the I2C\_Cmd() function.}
00066 \textcolor{comment}{  * }
00067 \textcolor{comment}{  *          9. Enable the DMA using the DMA\_Cmd() function when using DMA mode in the }
00068 \textcolor{comment}{  *             transfers. }
00069 \textcolor{comment}{  *}
00070 \textcolor{comment}{  *  @endverbatim}
00071 \textcolor{comment}{  *  }
00072 \textcolor{comment}{  ******************************************************************************}
00073 \textcolor{comment}{  * @attention}
00074 \textcolor{comment}{  *}
00075 \textcolor{comment}{  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS}
00076 \textcolor{comment}{  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE}
00077 \textcolor{comment}{  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY}
00078 \textcolor{comment}{  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING}
00079 \textcolor{comment}{  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE}
00080 \textcolor{comment}{  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.}
00081 \textcolor{comment}{  *}
00082 \textcolor{comment}{  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>}
00083 \textcolor{comment}{  ******************************************************************************  }
00084 \textcolor{comment}{  */}
00085 
00086 \textcolor{comment}{/* Includes ------------------------------------------------------------------*/}
00087 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} "stm32f4xx_i2c.h"
00088 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} "stm32f4xx_rcc.h"
00089 
00090 \textcolor{comment}{/** @addtogroup STM32F4xx\_StdPeriph\_Driver}
00091 \textcolor{comment}{  * @\{}
00092 \textcolor{comment}{  */}
00093 
00094 \textcolor{comment}{/** @defgroup I2C }
00095 \textcolor{comment}{  * @brief I2C driver modules}
00096 \textcolor{comment}{  * @\{}
00097 \textcolor{comment}{  */}
00098 
00099 \textcolor{comment}{/* Private typedef -----------------------------------------------------------*/}
00100 \textcolor{comment}{/* Private define ------------------------------------------------------------*/}
00101 
00102 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CR1\_CLEAR\_MASK}    \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint16\_t}\textcolor{preprocessor}{)}0xFBF5\textcolor{preprocessor}{)}      \textcolor{comment}{/*<! I2C registers Masks */}
00103 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{FLAG\_MASK}         \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}0x00FFFFFF\textcolor{preprocessor}{)}  \textcolor{comment}{/*<! I2C FLAG mask */}
00104 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ITEN\_MASK}         \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}0x07000000\textcolor{preprocessor}{)}  \textcolor{comment}{/*<! I2C Interrupt Enable mask */}
00105 
00106 \textcolor{comment}{/* Private macro -------------------------------------------------------------*/}
00107 \textcolor{comment}{/* Private variables ---------------------------------------------------------*/}
00108 \textcolor{comment}{/* Private function prototypes -----------------------------------------------*/}
00109 \textcolor{comment}{/* Private functions ---------------------------------------------------------*/}
00110 
00111 \textcolor{comment}{/** @defgroup I2C\_Private\_Functions}
00112 \textcolor{comment}{  * @\{}
00113 \textcolor{comment}{  */}
00114 
00115 \textcolor{comment}{/** @defgroup I2C\_Group1 Initialization and Configuration functions}
00116 \textcolor{comment}{ *  @brief   Initialization and Configuration functions }
00117 \textcolor{comment}{ *}
00118 \textcolor{comment}{@verbatim   }
00119 \textcolor{comment}{ ===============================================================================}
00120 \textcolor{comment}{                   Initialization and Configuration functions}
00121 \textcolor{comment}{ ===============================================================================  }
00122 \textcolor{comment}{}
00123 \textcolor{comment}{@endverbatim}
00124 \textcolor{comment}{  * @\{}
00125 \textcolor{comment}{  */}
00126 
00127 \textcolor{comment}{/**}
00128 \textcolor{comment}{  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.}
00129 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00130 \textcolor{comment}{  * @retval None}
00131 \textcolor{comment}{  */}
00132 \textcolor{keywordtype}{void} I2C_DeInit(I2C\_TypeDef* I2Cx)
00133 \{
00134   \textcolor{comment}{/* Check the parameters */}
00135   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00136 
00137   \textcolor{keywordflow}{if} (I2Cx == I2C1)
00138   \{
00139     \textcolor{comment}{/* Enable I2C1 reset state */}
00140     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00141     \textcolor{comment}{/* Release I2C1 from reset state */}
00142     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00143   \}
00144   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (I2Cx == I2C2)
00145   \{
00146     \textcolor{comment}{/* Enable I2C2 reset state */}
00147     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00148     \textcolor{comment}{/* Release I2C2 from reset state */}
00149     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00150   \}
00151   \textcolor{keywordflow}{else}
00152   \{
00153     \textcolor{keywordflow}{if} (I2Cx == I2C3)
00154     \{
00155       \textcolor{comment}{/* Enable I2C3 reset state */}
00156       RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
00157       \textcolor{comment}{/* Release I2C3 from reset state */}
00158       RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);
00159     \}
00160   \}
00161 \}
00162 
00163 \textcolor{comment}{/**}
00164 \textcolor{comment}{  * @brief  Initializes the I2Cx peripheral according to the specified }
00165 \textcolor{comment}{  *         parameters in the I2C\_InitStruct.}
00166 \textcolor{comment}{  *           }
00167 \textcolor{comment}{  * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency }
00168 \textcolor{comment}{  *         (I2C peripheral input clock) must be a multiple of 10 MHz.  }
00169 \textcolor{comment}{  *           }
00170 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00171 \textcolor{comment}{  * @param  I2C\_InitStruct: pointer to a I2C\_InitTypeDef structure that contains }
00172 \textcolor{comment}{  *         the configuration information for the specified I2C peripheral.}
00173 \textcolor{comment}{  * @retval None}
00174 \textcolor{comment}{  */}
00175 \textcolor{keywordtype}{void} I2C_Init(I2C\_TypeDef* I2Cx, I2C\_InitTypeDef* I2C\_InitStruct)
00176 \{
00177   uint16\_t tmpreg = 0, freqrange = 0;
00178   uint16\_t result = 0x04;
00179   uint32\_t pclk1 = 8000000;
00180   RCC\_ClocksTypeDef  rcc\_clocks;
00181   \textcolor{comment}{/* Check the parameters */}
00182   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00183   assert_param(IS\_I2C\_CLOCK\_SPEED(I2C\_InitStruct->I2C\_ClockSpeed));
00184   assert_param(IS\_I2C\_MODE(I2C\_InitStruct->I2C\_Mode));
00185   assert_param(IS\_I2C\_DUTY\_CYCLE(I2C\_InitStruct->I2C\_DutyCycle));
00186   assert_param(IS\_I2C\_OWN\_ADDRESS1(I2C\_InitStruct->I2C\_OwnAddress1));
00187   assert_param(IS\_I2C\_ACK\_STATE(I2C\_InitStruct->I2C\_Ack));
00188   assert_param(IS\_I2C\_ACKNOWLEDGE\_ADDRESS(I2C\_InitStruct->I2C\_AcknowledgedAddress));
00189 
00190 \textcolor{comment}{/*---------------------------- I2Cx CR2 Configuration ------------------------*/}
00191   \textcolor{comment}{/* Get the I2Cx CR2 value */}
00192   tmpreg = I2Cx->CR2;
00193   \textcolor{comment}{/* Clear frequency FREQ[5:0] bits */}
00194   tmpreg &= (uint16\_t)~((uint16\_t)I2C_CR2_FREQ);
00195   \textcolor{comment}{/* Get pclk1 frequency value */}
00196   RCC_GetClocksFreq(&rcc\_clocks);
00197   pclk1 = rcc\_clocks.PCLK1_Frequency;
00198   \textcolor{comment}{/* Set frequency bits depending on pclk1 value */}
00199   freqrange = (uint16\_t)(pclk1 / 1000000);
00200   tmpreg |= freqrange;
00201   \textcolor{comment}{/* Write to I2Cx CR2 */}
00202   I2Cx->CR2 = tmpreg;
00203 
00204 \textcolor{comment}{/*---------------------------- I2Cx CCR Configuration ------------------------*/}
00205   \textcolor{comment}{/* Disable the selected I2C peripheral to configure TRISE */}
00206   I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_PE);
00207   \textcolor{comment}{/* Reset tmpreg value */}
00208   \textcolor{comment}{/* Clear F/S, DUTY and CCR[11:0] bits */}
00209   tmpreg = 0;
00210 
00211   \textcolor{comment}{/* Configure speed in standard mode */}
00212   \textcolor{keywordflow}{if} (I2C\_InitStruct->I2C_ClockSpeed <= 100000)
00213   \{
00214     \textcolor{comment}{/* Standard mode speed calculate */}
00215     result = (uint16\_t)(pclk1 / (I2C\_InitStruct->I2C_ClockSpeed << 1));
00216     \textcolor{comment}{/* Test if CCR value is under 0x4*/}
00217     \textcolor{keywordflow}{if} (result < 0x04)
00218     \{
00219       \textcolor{comment}{/* Set minimum allowed value */}
00220       result = 0x04;
00221     \}
00222     \textcolor{comment}{/* Set speed value for standard mode */}
00223     tmpreg |= result;
00224     \textcolor{comment}{/* Set Maximum Rise Time for standard mode */}
00225     I2Cx->TRISE = freqrange + 1;
00226   \}
00227   \textcolor{comment}{/* Configure speed in fast mode */}
00228   \textcolor{comment}{/* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral}
00229 \textcolor{comment}{     input clock) must be a multiple of 10 MHz */}
00230   \textcolor{keywordflow}{else} \textcolor{comment}{/*(I2C\_InitStruct->I2C\_ClockSpeed <= 400000)*/}
00231   \{
00232     \textcolor{keywordflow}{if} (I2C\_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
00233     \{
00234       \textcolor{comment}{/* Fast mode speed calculate: Tlow/Thigh = 2 */}
00235       result = (uint16\_t)(pclk1 / (I2C\_InitStruct->I2C_ClockSpeed * 3));
00236     \}
00237     \textcolor{keywordflow}{else} \textcolor{comment}{/*I2C\_InitStruct->I2C\_DutyCycle == I2C\_DutyCycle\_16\_9*/}
00238     \{
00239       \textcolor{comment}{/* Fast mode speed calculate: Tlow/Thigh = 16/9 */}
00240       result = (uint16\_t)(pclk1 / (I2C\_InitStruct->I2C_ClockSpeed * 25));
00241       \textcolor{comment}{/* Set DUTY bit */}
00242       result |= I2C_DutyCycle_16_9;
00243     \}
00244 
00245     \textcolor{comment}{/* Test if CCR value is under 0x1*/}
00246     \textcolor{keywordflow}{if} ((result & I2C_CCR_CCR) == 0)
00247     \{
00248       \textcolor{comment}{/* Set minimum allowed value */}
00249       result |= (uint16\_t)0x0001;
00250     \}
00251     \textcolor{comment}{/* Set speed value and set F/S bit for fast mode */}
00252     tmpreg |= (uint16\_t)(result | I2C_CCR_FS);
00253     \textcolor{comment}{/* Set Maximum Rise Time for fast mode */}
00254     I2Cx->TRISE = (uint16\_t)(((freqrange * (uint16\_t)300) / (uint16\_t)1000) + (uint16\_t)1);
00255   \}
00256 
00257   \textcolor{comment}{/* Write to I2Cx CCR */}
00258   I2Cx->CCR = tmpreg;
00259   \textcolor{comment}{/* Enable the selected I2C peripheral */}
00260   I2Cx->CR1 |= I2C_CR1_PE;
00261 
00262 \textcolor{comment}{/*---------------------------- I2Cx CR1 Configuration ------------------------*/}
00263   \textcolor{comment}{/* Get the I2Cx CR1 value */}
00264   tmpreg = I2Cx->CR1;
00265   \textcolor{comment}{/* Clear ACK, SMBTYPE and  SMBUS bits */}
00266   tmpreg &= CR1_CLEAR_MASK;
00267   \textcolor{comment}{/* Configure I2Cx: mode and acknowledgement */}
00268   \textcolor{comment}{/* Set SMBTYPE and SMBUS bits according to I2C\_Mode value */}
00269   \textcolor{comment}{/* Set ACK bit according to I2C\_Ack value */}
00270   tmpreg |= (uint16\_t)((uint32\_t)I2C\_InitStruct->I2C_Mode | I2C\_InitStruct
      ->I2C_Ack);
00271   \textcolor{comment}{/* Write to I2Cx CR1 */}
00272   I2Cx->CR1 = tmpreg;
00273 
00274 \textcolor{comment}{/*---------------------------- I2Cx OAR1 Configuration -----------------------*/}
00275   \textcolor{comment}{/* Set I2Cx Own Address1 and acknowledged address */}
00276   I2Cx->OAR1 = (I2C\_InitStruct->I2C\_AcknowledgedAddress | I2C\_InitStruct->I2C\_OwnAddress1);
00277 \}
00278 
00279 \textcolor{comment}{/**}
00280 \textcolor{comment}{  * @brief  Fills each I2C\_InitStruct member with its default value.}
00281 \textcolor{comment}{  * @param  I2C\_InitStruct: pointer to an I2C\_InitTypeDef structure which will be initialized.}
00282 \textcolor{comment}{  * @retval None}
00283 \textcolor{comment}{  */}
00284 \textcolor{keywordtype}{void} I2C_StructInit(I2C\_InitTypeDef* I2C\_InitStruct)
00285 \{
00286 \textcolor{comment}{/*---------------- Reset I2C init structure parameters values ----------------*/}
00287   \textcolor{comment}{/* initialize the I2C\_ClockSpeed member */}
00288   I2C\_InitStruct->I2C_ClockSpeed = 5000;
00289   \textcolor{comment}{/* Initialize the I2C\_Mode member */}
00290   I2C\_InitStruct->I2C_Mode = I2C_Mode_I2C;
00291   \textcolor{comment}{/* Initialize the I2C\_DutyCycle member */}
00292   I2C\_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00293   \textcolor{comment}{/* Initialize the I2C\_OwnAddress1 member */}
00294   I2C\_InitStruct->I2C_OwnAddress1 = 0;
00295   \textcolor{comment}{/* Initialize the I2C\_Ack member */}
00296   I2C\_InitStruct->I2C_Ack = I2C_Ack_Disable;
00297   \textcolor{comment}{/* Initialize the I2C\_AcknowledgedAddress member */}
00298   I2C\_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00299 \}
00300 
00301 \textcolor{comment}{/**}
00302 \textcolor{comment}{  * @brief  Enables or disables the specified I2C peripheral.}
00303 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00304 \textcolor{comment}{  * @param  NewState: new state of the I2Cx peripheral. }
00305 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00306 \textcolor{comment}{  * @retval None}
00307 \textcolor{comment}{  */}
00308 \textcolor{keywordtype}{void} I2C_Cmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00309 \{
00310   \textcolor{comment}{/* Check the parameters */}
00311   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00312   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00313   \textcolor{keywordflow}{if} (NewState != DISABLE)
00314   \{
00315     \textcolor{comment}{/* Enable the selected I2C peripheral */}
00316     I2Cx->CR1 |= I2C_CR1_PE;
00317   \}
00318   \textcolor{keywordflow}{else}
00319   \{
00320     \textcolor{comment}{/* Disable the selected I2C peripheral */}
00321     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_PE);
00322   \}
00323 \}
00324 
00325 \textcolor{comment}{/**}
00326 \textcolor{comment}{  * @brief  Generates I2Cx communication START condition.}
00327 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00328 \textcolor{comment}{  * @param  NewState: new state of the I2C START condition generation.}
00329 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00330 \textcolor{comment}{  * @retval None.}
00331 \textcolor{comment}{  */}
00332 \textcolor{keywordtype}{void} I2C_GenerateSTART(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00333 \{
00334   \textcolor{comment}{/* Check the parameters */}
00335   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00336   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00337   \textcolor{keywordflow}{if} (NewState != DISABLE)
00338   \{
00339     \textcolor{comment}{/* Generate a START condition */}
00340     I2Cx->CR1 |= I2C_CR1_START;
00341   \}
00342   \textcolor{keywordflow}{else}
00343   \{
00344     \textcolor{comment}{/* Disable the START condition generation */}
00345     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_START);
00346   \}
00347 \}
00348 
00349 \textcolor{comment}{/**}
00350 \textcolor{comment}{  * @brief  Generates I2Cx communication STOP condition.}
00351 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00352 \textcolor{comment}{  * @param  NewState: new state of the I2C STOP condition generation.}
00353 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00354 \textcolor{comment}{  * @retval None.}
00355 \textcolor{comment}{  */}
00356 \textcolor{keywordtype}{void} I2C_GenerateSTOP(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00357 \{
00358   \textcolor{comment}{/* Check the parameters */}
00359   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00360   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00361   \textcolor{keywordflow}{if} (NewState != DISABLE)
00362   \{
00363     \textcolor{comment}{/* Generate a STOP condition */}
00364     I2Cx->CR1 |= I2C_CR1_STOP;
00365   \}
00366   \textcolor{keywordflow}{else}
00367   \{
00368     \textcolor{comment}{/* Disable the STOP condition generation */}
00369     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_STOP);
00370   \}
00371 \}
00372 
00373 \textcolor{comment}{/**}
00374 \textcolor{comment}{  * @brief  Transmits the address byte to select the slave device.}
00375 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00376 \textcolor{comment}{  * @param  Address: specifies the slave address which will be transmitted}
00377 \textcolor{comment}{  * @param  I2C\_Direction: specifies whether the I2C device will be a Transmitter}
00378 \textcolor{comment}{  *         or a Receiver. }
00379 \textcolor{comment}{  *          This parameter can be one of the following values}
00380 \textcolor{comment}{  *            @arg I2C\_Direction\_Transmitter: Transmitter mode}
00381 \textcolor{comment}{  *            @arg I2C\_Direction\_Receiver: Receiver mode}
00382 \textcolor{comment}{  * @retval None.}
00383 \textcolor{comment}{  */}
00384 \textcolor{keywordtype}{void} I2C_Send7bitAddress(I2C\_TypeDef* I2Cx, uint8\_t Address, uint8\_t I2C\_Direction)
00385 \{
00386   \textcolor{comment}{/* Check the parameters */}
00387   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00388   assert_param(IS\_I2C\_DIRECTION(I2C\_Direction));
00389   \textcolor{comment}{/* Test on the direction to set/reset the read/write bit */}
00390   \textcolor{keywordflow}{if} (I2C\_Direction != I2C_Direction_Transmitter)
00391   \{
00392     \textcolor{comment}{/* Set the address bit0 for read */}
00393     Address |= I2C_OAR1_ADD0;
00394   \}
00395   \textcolor{keywordflow}{else}
00396   \{
00397     \textcolor{comment}{/* Reset the address bit0 for write */}
00398     Address &= (uint8\_t)~((uint8\_t)I2C_OAR1_ADD0);
00399   \}
00400   \textcolor{comment}{/* Send the address */}
00401   I2Cx->DR = Address;
00402 \}
00403 
00404 \textcolor{comment}{/**}
00405 \textcolor{comment}{  * @brief  Enables or disables the specified I2C acknowledge feature.}
00406 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00407 \textcolor{comment}{  * @param  NewState: new state of the I2C Acknowledgement.}
00408 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00409 \textcolor{comment}{  * @retval None.}
00410 \textcolor{comment}{  */}
00411 \textcolor{keywordtype}{void} I2C_AcknowledgeConfig(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00412 \{
00413   \textcolor{comment}{/* Check the parameters */}
00414   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00415   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00416   \textcolor{keywordflow}{if} (NewState != DISABLE)
00417   \{
00418     \textcolor{comment}{/* Enable the acknowledgement */}
00419     I2Cx->CR1 |= I2C_CR1_ACK;
00420   \}
00421   \textcolor{keywordflow}{else}
00422   \{
00423     \textcolor{comment}{/* Disable the acknowledgement */}
00424     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_ACK);
00425   \}
00426 \}
00427 
00428 \textcolor{comment}{/**}
00429 \textcolor{comment}{  * @brief  Configures the specified I2C own address2.}
00430 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00431 \textcolor{comment}{  * @param  Address: specifies the 7bit I2C own address2.}
00432 \textcolor{comment}{  * @retval None.}
00433 \textcolor{comment}{  */}
00434 \textcolor{keywordtype}{void} I2C_OwnAddress2Config(I2C\_TypeDef* I2Cx, uint8\_t Address)
00435 \{
00436   uint16\_t tmpreg = 0;
00437 
00438   \textcolor{comment}{/* Check the parameters */}
00439   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00440 
00441   \textcolor{comment}{/* Get the old register value */}
00442   tmpreg = I2Cx->OAR2;
00443 
00444   \textcolor{comment}{/* Reset I2Cx Own address2 bit [7:1] */}
00445   tmpreg &= (uint16\_t)~((uint16\_t)I2C_OAR2_ADD2);
00446 
00447   \textcolor{comment}{/* Set I2Cx Own address2 */}
00448   tmpreg |= (uint16\_t)((uint16\_t)Address & (uint16\_t)0x00FE);
00449 
00450   \textcolor{comment}{/* Store the new register value */}
00451   I2Cx->OAR2 = tmpreg;
00452 \}
00453 
00454 \textcolor{comment}{/**}
00455 \textcolor{comment}{  * @brief  Enables or disables the specified I2C dual addressing mode.}
00456 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00457 \textcolor{comment}{  * @param  NewState: new state of the I2C dual addressing mode.}
00458 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00459 \textcolor{comment}{  * @retval None}
00460 \textcolor{comment}{  */}
00461 \textcolor{keywordtype}{void} I2C_DualAddressCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00462 \{
00463   \textcolor{comment}{/* Check the parameters */}
00464   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00465   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00466   \textcolor{keywordflow}{if} (NewState != DISABLE)
00467   \{
00468     \textcolor{comment}{/* Enable dual addressing mode */}
00469     I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
00470   \}
00471   \textcolor{keywordflow}{else}
00472   \{
00473     \textcolor{comment}{/* Disable dual addressing mode */}
00474     I2Cx->OAR2 &= (uint16\_t)~((uint16\_t)I2C_OAR2_ENDUAL);
00475   \}
00476 \}
00477 
00478 \textcolor{comment}{/**}
00479 \textcolor{comment}{  * @brief  Enables or disables the specified I2C general call feature.}
00480 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00481 \textcolor{comment}{  * @param  NewState: new state of the I2C General call.}
00482 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00483 \textcolor{comment}{  * @retval None}
00484 \textcolor{comment}{  */}
00485 \textcolor{keywordtype}{void} I2C_GeneralCallCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00486 \{
00487   \textcolor{comment}{/* Check the parameters */}
00488   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00489   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00490   \textcolor{keywordflow}{if} (NewState != DISABLE)
00491   \{
00492     \textcolor{comment}{/* Enable generall call */}
00493     I2Cx->CR1 |= I2C_CR1_ENGC;
00494   \}
00495   \textcolor{keywordflow}{else}
00496   \{
00497     \textcolor{comment}{/* Disable generall call */}
00498     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_ENGC);
00499   \}
00500 \}
00501 
00502 \textcolor{comment}{/**}
00503 \textcolor{comment}{  * @brief  Enables or disables the specified I2C software reset.}
00504 \textcolor{comment}{  * @note   When software reset is enabled, the I2C IOs are released (this can}
00505 \textcolor{comment}{  *         be useful to recover from bus errors).  }
00506 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00507 \textcolor{comment}{  * @param  NewState: new state of the I2C software reset.}
00508 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00509 \textcolor{comment}{  * @retval None}
00510 \textcolor{comment}{  */}
00511 \textcolor{keywordtype}{void} I2C_SoftwareResetCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00512 \{
00513   \textcolor{comment}{/* Check the parameters */}
00514   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00515   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00516   \textcolor{keywordflow}{if} (NewState != DISABLE)
00517   \{
00518     \textcolor{comment}{/* Peripheral under reset */}
00519     I2Cx->CR1 |= I2C_CR1_SWRST;
00520   \}
00521   \textcolor{keywordflow}{else}
00522   \{
00523     \textcolor{comment}{/* Peripheral not under reset */}
00524     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_SWRST);
00525   \}
00526 \}
00527 
00528 \textcolor{comment}{/**}
00529 \textcolor{comment}{  * @brief  Enables or disables the specified I2C Clock stretching.}
00530 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00531 \textcolor{comment}{  * @param  NewState: new state of the I2Cx Clock stretching.}
00532 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00533 \textcolor{comment}{  * @retval None}
00534 \textcolor{comment}{  */}
00535 \textcolor{keywordtype}{void} I2C_StretchClockCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00536 \{
00537   \textcolor{comment}{/* Check the parameters */}
00538   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00539   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00540   \textcolor{keywordflow}{if} (NewState == DISABLE)
00541   \{
00542     \textcolor{comment}{/* Enable the selected I2C Clock stretching */}
00543     I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
00544   \}
00545   \textcolor{keywordflow}{else}
00546   \{
00547     \textcolor{comment}{/* Disable the selected I2C Clock stretching */}
00548     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_NOSTRETCH);
00549   \}
00550 \}
00551 
00552 \textcolor{comment}{/**}
00553 \textcolor{comment}{  * @brief  Selects the specified I2C fast mode duty cycle.}
00554 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00555 \textcolor{comment}{  * @param  I2C\_DutyCycle: specifies the fast mode duty cycle.}
00556 \textcolor{comment}{  *          This parameter can be one of the following values:}
00557 \textcolor{comment}{  *            @arg I2C\_DutyCycle\_2: I2C fast mode Tlow/Thigh = 2}
00558 \textcolor{comment}{  *            @arg I2C\_DutyCycle\_16\_9: I2C fast mode Tlow/Thigh = 16/9}
00559 \textcolor{comment}{  * @retval None}
00560 \textcolor{comment}{  */}
00561 \textcolor{keywordtype}{void} I2C_FastModeDutyCycleConfig(I2C\_TypeDef* I2Cx, uint16\_t I2C\_DutyCycle)
00562 \{
00563   \textcolor{comment}{/* Check the parameters */}
00564   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00565   assert_param(IS\_I2C\_DUTY\_CYCLE(I2C\_DutyCycle));
00566   \textcolor{keywordflow}{if} (I2C\_DutyCycle != I2C_DutyCycle_16_9)
00567   \{
00568     \textcolor{comment}{/* I2C fast mode Tlow/Thigh=2 */}
00569     I2Cx->CCR &= I2C_DutyCycle_2;
00570   \}
00571   \textcolor{keywordflow}{else}
00572   \{
00573     \textcolor{comment}{/* I2C fast mode Tlow/Thigh=16/9 */}
00574     I2Cx->CCR |= I2C_DutyCycle_16_9;
00575   \}
00576 \}
00577 
00578 \textcolor{comment}{/**}
00579 \textcolor{comment}{  * @brief  Selects the specified I2C NACK position in master receiver mode.}
00580 \textcolor{comment}{  * @note   This function is useful in I2C Master Receiver mode when the number}
00581 \textcolor{comment}{  *         of data to be received is equal to 2. In this case, this function }
00582 \textcolor{comment}{  *         should be called (with parameter I2C\_NACKPosition\_Next) before data }
00583 \textcolor{comment}{  *         reception starts,as described in the 2-byte reception procedure }
00584 \textcolor{comment}{  *         recommended in Reference Manual in Section: Master receiver.                }
00585 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00586 \textcolor{comment}{  * @param  I2C\_NACKPosition: specifies the NACK position. }
00587 \textcolor{comment}{  *          This parameter can be one of the following values:}
00588 \textcolor{comment}{  *            @arg I2C\_NACKPosition\_Next: indicates that the next byte will be the last}
00589 \textcolor{comment}{  *                                        received byte.  }
00590 \textcolor{comment}{  *            @arg I2C\_NACKPosition\_Current: indicates that current byte is the last }
00591 \textcolor{comment}{  *                                           received byte.}
00592 \textcolor{comment}{  *            }
00593 \textcolor{comment}{  * @note    This function configures the same bit (POS) as I2C\_PECPositionConfig() }
00594 \textcolor{comment}{  *          but is intended to be used in I2C mode while I2C\_PECPositionConfig() }
00595 \textcolor{comment}{  *          is intended to used in SMBUS mode. }
00596 \textcolor{comment}{  *            }
00597 \textcolor{comment}{  * @retval None}
00598 \textcolor{comment}{  */}
00599 \textcolor{keywordtype}{void} I2C_NACKPositionConfig(I2C\_TypeDef* I2Cx, uint16\_t I2C\_NACKPosition)
00600 \{
00601   \textcolor{comment}{/* Check the parameters */}
00602   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00603   assert_param(IS\_I2C\_NACK\_POSITION(I2C\_NACKPosition));
00604 
00605   \textcolor{comment}{/* Check the input parameter */}
00606   \textcolor{keywordflow}{if} (I2C\_NACKPosition == I2C_NACKPosition_Next)
00607   \{
00608     \textcolor{comment}{/* Next byte in shift register is the last received byte */}
00609     I2Cx->CR1 |= I2C_NACKPosition_Next;
00610   \}
00611   \textcolor{keywordflow}{else}
00612   \{
00613     \textcolor{comment}{/* Current byte in shift register is the last received byte */}
00614     I2Cx->CR1 &= I2C_NACKPosition_Current;
00615   \}
00616 \}
00617 
00618 \textcolor{comment}{/**}
00619 \textcolor{comment}{  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.}
00620 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00621 \textcolor{comment}{  * @param  I2C\_SMBusAlert: specifies SMBAlert pin level. }
00622 \textcolor{comment}{  *          This parameter can be one of the following values:}
00623 \textcolor{comment}{  *            @arg I2C\_SMBusAlert\_Low: SMBAlert pin driven low}
00624 \textcolor{comment}{  *            @arg I2C\_SMBusAlert\_High: SMBAlert pin driven high}
00625 \textcolor{comment}{  * @retval None}
00626 \textcolor{comment}{  */}
00627 \textcolor{keywordtype}{void} I2C_SMBusAlertConfig(I2C\_TypeDef* I2Cx, uint16\_t I2C\_SMBusAlert)
00628 \{
00629   \textcolor{comment}{/* Check the parameters */}
00630   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00631   assert_param(IS\_I2C\_SMBUS\_ALERT(I2C\_SMBusAlert));
00632   \textcolor{keywordflow}{if} (I2C\_SMBusAlert == I2C_SMBusAlert_Low)
00633   \{
00634     \textcolor{comment}{/* Drive the SMBusAlert pin Low */}
00635     I2Cx->CR1 |= I2C_SMBusAlert_Low;
00636   \}
00637   \textcolor{keywordflow}{else}
00638   \{
00639     \textcolor{comment}{/* Drive the SMBusAlert pin High  */}
00640     I2Cx->CR1 &= I2C_SMBusAlert_High;
00641   \}
00642 \}
00643 
00644 \textcolor{comment}{/**}
00645 \textcolor{comment}{  * @brief  Enables or disables the specified I2C ARP.}
00646 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00647 \textcolor{comment}{  * @param  NewState: new state of the I2Cx ARP. }
00648 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00649 \textcolor{comment}{  * @retval None}
00650 \textcolor{comment}{  */}
00651 \textcolor{keywordtype}{void} I2C_ARPCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00652 \{
00653   \textcolor{comment}{/* Check the parameters */}
00654   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00655   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00656   \textcolor{keywordflow}{if} (NewState != DISABLE)
00657   \{
00658     \textcolor{comment}{/* Enable the selected I2C ARP */}
00659     I2Cx->CR1 |= I2C_CR1_ENARP;
00660   \}
00661   \textcolor{keywordflow}{else}
00662   \{
00663     \textcolor{comment}{/* Disable the selected I2C ARP */}
00664     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_ENARP);
00665   \}
00666 \}
00667 \textcolor{comment}{/**}
00668 \textcolor{comment}{  * @\}}
00669 \textcolor{comment}{  */}
00670 
00671 \textcolor{comment}{/** @defgroup I2C\_Group2 Data transfers functions}
00672 \textcolor{comment}{ *  @brief   Data transfers functions }
00673 \textcolor{comment}{ *}
00674 \textcolor{comment}{@verbatim   }
00675 \textcolor{comment}{ ===============================================================================}
00676 \textcolor{comment}{                        Data transfers functions}
00677 \textcolor{comment}{ ===============================================================================  }
00678 \textcolor{comment}{}
00679 \textcolor{comment}{@endverbatim}
00680 \textcolor{comment}{  * @\{}
00681 \textcolor{comment}{  */}
00682 
00683 \textcolor{comment}{/**}
00684 \textcolor{comment}{  * @brief  Sends a data byte through the I2Cx peripheral.}
00685 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00686 \textcolor{comment}{  * @param  Data: Byte to be transmitted..}
00687 \textcolor{comment}{  * @retval None}
00688 \textcolor{comment}{  */}
00689 \textcolor{keywordtype}{void} I2C_SendData(I2C\_TypeDef* I2Cx, uint8\_t Data)
00690 \{
00691   \textcolor{comment}{/* Check the parameters */}
00692   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00693   \textcolor{comment}{/* Write in the DR register the data to be sent */}
00694   I2Cx->DR = Data;
00695 \}
00696 
00697 \textcolor{comment}{/**}
00698 \textcolor{comment}{  * @brief  Returns the most recent received data by the I2Cx peripheral.}
00699 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00700 \textcolor{comment}{  * @retval The value of the received data.}
00701 \textcolor{comment}{  */}
00702 uint8\_t I2C_ReceiveData(I2C\_TypeDef* I2Cx)
00703 \{
00704   \textcolor{comment}{/* Check the parameters */}
00705   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00706   \textcolor{comment}{/* Return the data in the DR register */}
00707   \textcolor{keywordflow}{return} (uint8\_t)I2Cx->DR;
00708 \}
00709 
00710 \textcolor{comment}{/**}
00711 \textcolor{comment}{  * @\}}
00712 \textcolor{comment}{  */}
00713 
00714 \textcolor{comment}{/** @defgroup I2C\_Group3 PEC management functions}
00715 \textcolor{comment}{ *  @brief   PEC management functions }
00716 \textcolor{comment}{ *}
00717 \textcolor{comment}{@verbatim   }
00718 \textcolor{comment}{ ===============================================================================}
00719 \textcolor{comment}{                         PEC management functions}
00720 \textcolor{comment}{ ===============================================================================  }
00721 \textcolor{comment}{}
00722 \textcolor{comment}{@endverbatim}
00723 \textcolor{comment}{  * @\{}
00724 \textcolor{comment}{  */}
00725 
00726 \textcolor{comment}{/**}
00727 \textcolor{comment}{  * @brief  Enables or disables the specified I2C PEC transfer.}
00728 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00729 \textcolor{comment}{  * @param  NewState: new state of the I2C PEC transmission.}
00730 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00731 \textcolor{comment}{  * @retval None}
00732 \textcolor{comment}{  */}
00733 \textcolor{keywordtype}{void} I2C_TransmitPEC(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00734 \{
00735   \textcolor{comment}{/* Check the parameters */}
00736   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00737   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00738   \textcolor{keywordflow}{if} (NewState != DISABLE)
00739   \{
00740     \textcolor{comment}{/* Enable the selected I2C PEC transmission */}
00741     I2Cx->CR1 |= I2C_CR1_PEC;
00742   \}
00743   \textcolor{keywordflow}{else}
00744   \{
00745     \textcolor{comment}{/* Disable the selected I2C PEC transmission */}
00746     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_PEC);
00747   \}
00748 \}
00749 
00750 \textcolor{comment}{/**}
00751 \textcolor{comment}{  * @brief  Selects the specified I2C PEC position.}
00752 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00753 \textcolor{comment}{  * @param  I2C\_PECPosition: specifies the PEC position. }
00754 \textcolor{comment}{  *          This parameter can be one of the following values:}
00755 \textcolor{comment}{  *            @arg I2C\_PECPosition\_Next: indicates that the next byte is PEC}
00756 \textcolor{comment}{  *            @arg I2C\_PECPosition\_Current: indicates that current byte is PEC}
00757 \textcolor{comment}{  *       }
00758 \textcolor{comment}{  * @note    This function configures the same bit (POS) as I2C\_NACKPositionConfig()}
00759 \textcolor{comment}{  *          but is intended to be used in SMBUS mode while I2C\_NACKPositionConfig() }
00760 \textcolor{comment}{  *          is intended to used in I2C mode.}
00761 \textcolor{comment}{  *                }
00762 \textcolor{comment}{  * @retval None}
00763 \textcolor{comment}{  */}
00764 \textcolor{keywordtype}{void} I2C_PECPositionConfig(I2C\_TypeDef* I2Cx, uint16\_t I2C\_PECPosition)
00765 \{
00766   \textcolor{comment}{/* Check the parameters */}
00767   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00768   assert_param(IS\_I2C\_PEC\_POSITION(I2C\_PECPosition));
00769   \textcolor{keywordflow}{if} (I2C\_PECPosition == I2C_PECPosition_Next)
00770   \{
00771     \textcolor{comment}{/* Next byte in shift register is PEC */}
00772     I2Cx->CR1 |= I2C_PECPosition_Next;
00773   \}
00774   \textcolor{keywordflow}{else}
00775   \{
00776     \textcolor{comment}{/* Current byte in shift register is PEC */}
00777     I2Cx->CR1 &= I2C_PECPosition_Current;
00778   \}
00779 \}
00780 
00781 \textcolor{comment}{/**}
00782 \textcolor{comment}{  * @brief  Enables or disables the PEC value calculation of the transferred bytes.}
00783 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00784 \textcolor{comment}{  * @param  NewState: new state of the I2Cx PEC value calculation.}
00785 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00786 \textcolor{comment}{  * @retval None}
00787 \textcolor{comment}{  */}
00788 \textcolor{keywordtype}{void} I2C_CalculatePEC(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00789 \{
00790   \textcolor{comment}{/* Check the parameters */}
00791   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00792   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00793   \textcolor{keywordflow}{if} (NewState != DISABLE)
00794   \{
00795     \textcolor{comment}{/* Enable the selected I2C PEC calculation */}
00796     I2Cx->CR1 |= I2C_CR1_ENPEC;
00797   \}
00798   \textcolor{keywordflow}{else}
00799   \{
00800     \textcolor{comment}{/* Disable the selected I2C PEC calculation */}
00801     I2Cx->CR1 &= (uint16\_t)~((uint16\_t)I2C_CR1_ENPEC);
00802   \}
00803 \}
00804 
00805 \textcolor{comment}{/**}
00806 \textcolor{comment}{  * @brief  Returns the PEC value for the specified I2C.}
00807 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00808 \textcolor{comment}{  * @retval The PEC value.}
00809 \textcolor{comment}{  */}
00810 uint8\_t I2C_GetPEC(I2C\_TypeDef* I2Cx)
00811 \{
00812   \textcolor{comment}{/* Check the parameters */}
00813   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00814   \textcolor{comment}{/* Return the selected I2C PEC value */}
00815   \textcolor{keywordflow}{return} ((I2Cx->SR2) >> 8);
00816 \}
00817 
00818 \textcolor{comment}{/**}
00819 \textcolor{comment}{  * @\}}
00820 \textcolor{comment}{  */}
00821 
00822 \textcolor{comment}{/** @defgroup I2C\_Group4 DMA transfers management functions}
00823 \textcolor{comment}{ *  @brief   DMA transfers management functions }
00824 \textcolor{comment}{ *}
00825 \textcolor{comment}{@verbatim   }
00826 \textcolor{comment}{ ===============================================================================}
00827 \textcolor{comment}{                         DMA transfers management functions}
00828 \textcolor{comment}{ ===============================================================================  }
00829 \textcolor{comment}{  This section provides functions allowing to configure the I2C DMA channels }
00830 \textcolor{comment}{  requests.}
00831 \textcolor{comment}{  }
00832 \textcolor{comment}{@endverbatim}
00833 \textcolor{comment}{  * @\{}
00834 \textcolor{comment}{  */}
00835 
00836 \textcolor{comment}{/**}
00837 \textcolor{comment}{  * @brief  Enables or disables the specified I2C DMA requests.}
00838 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00839 \textcolor{comment}{  * @param  NewState: new state of the I2C DMA transfer.}
00840 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00841 \textcolor{comment}{  * @retval None}
00842 \textcolor{comment}{  */}
00843 \textcolor{keywordtype}{void} I2C_DMACmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00844 \{
00845   \textcolor{comment}{/* Check the parameters */}
00846   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00847   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00848   \textcolor{keywordflow}{if} (NewState != DISABLE)
00849   \{
00850     \textcolor{comment}{/* Enable the selected I2C DMA requests */}
00851     I2Cx->CR2 |= I2C_CR2_DMAEN;
00852   \}
00853   \textcolor{keywordflow}{else}
00854   \{
00855     \textcolor{comment}{/* Disable the selected I2C DMA requests */}
00856     I2Cx->CR2 &= (uint16\_t)~((uint16\_t)I2C_CR2_DMAEN);
00857   \}
00858 \}
00859 
00860 \textcolor{comment}{/**}
00861 \textcolor{comment}{  * @brief  Specifies that the next DMA transfer is the last one.}
00862 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
00863 \textcolor{comment}{  * @param  NewState: new state of the I2C DMA last transfer.}
00864 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
00865 \textcolor{comment}{  * @retval None}
00866 \textcolor{comment}{  */}
00867 \textcolor{keywordtype}{void} I2C_DMALastTransferCmd(I2C\_TypeDef* I2Cx, FunctionalState NewState)
00868 \{
00869   \textcolor{comment}{/* Check the parameters */}
00870   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
00871   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
00872   \textcolor{keywordflow}{if} (NewState != DISABLE)
00873   \{
00874     \textcolor{comment}{/* Next DMA transfer is the last transfer */}
00875     I2Cx->CR2 |= I2C_CR2_LAST;
00876   \}
00877   \textcolor{keywordflow}{else}
00878   \{
00879     \textcolor{comment}{/* Next DMA transfer is not the last transfer */}
00880     I2Cx->CR2 &= (uint16\_t)~((uint16\_t)I2C_CR2_LAST);
00881   \}
00882 \}
00883 
00884 \textcolor{comment}{/**}
00885 \textcolor{comment}{  * @\}}
00886 \textcolor{comment}{  */}
00887 
00888 \textcolor{comment}{/** @defgroup I2C\_Group5 Interrupts events and flags management functions}
00889 \textcolor{comment}{ *  @brief   Interrupts, events and flags management functions}
00890 \textcolor{comment}{ *}
00891 \textcolor{comment}{@verbatim   }
00892 \textcolor{comment}{ ===============================================================================}
00893 \textcolor{comment}{                Interrupts, events and flags management functions}
00894 \textcolor{comment}{ ===============================================================================  }
00895 \textcolor{comment}{  This section provides functions allowing to configure the I2C Interrupts }
00896 \textcolor{comment}{  sources and check or clear the flags or pending bits status.}
00897 \textcolor{comment}{  The user should identify which mode will be used in his application to manage }
00898 \textcolor{comment}{  the communication: Polling mode, Interrupt mode or DMA mode. }
00899 \textcolor{comment}{}
00900 \textcolor{comment}{ ===============================================================================}
00901 \textcolor{comment}{                          I2C State Monitoring Functions                    }
00902 \textcolor{comment}{ ===============================================================================   }
00903 \textcolor{comment}{  This I2C driver provides three different ways for I2C state monitoring}
00904 \textcolor{comment}{  depending on the application requirements and constraints:}
00905 \textcolor{comment}{         }
00906 \textcolor{comment}{   }
00907 \textcolor{comment}{     1. Basic state monitoring (Using I2C\_CheckEvent() function)}
00908 \textcolor{comment}{     -----------------------------------------------------------}
00909 \textcolor{comment}{        It compares the status registers (SR1 and SR2) content to a given event}
00910 \textcolor{comment}{        (can be the combination of one or more flags).}
00911 \textcolor{comment}{        It returns SUCCESS if the current status includes the given flags }
00912 \textcolor{comment}{        and returns ERROR if one or more flags are missing in the current status.}
00913 \textcolor{comment}{}
00914 \textcolor{comment}{          - When to use}
00915 \textcolor{comment}{             - This function is suitable for most applications as well as for startup }
00916 \textcolor{comment}{               activity since the events are fully described in the product reference }
00917 \textcolor{comment}{               manual (RM0090).}
00918 \textcolor{comment}{             - It is also suitable for users who need to define their own events.}
00919 \textcolor{comment}{}
00920 \textcolor{comment}{          - Limitations}
00921 \textcolor{comment}{             - If an error occurs (ie. error flags are set besides to the monitored }
00922 \textcolor{comment}{               flags), the I2C\_CheckEvent() function may return SUCCESS despite }
00923 \textcolor{comment}{               the communication hold or corrupted real state. }
00924 \textcolor{comment}{               In this case, it is advised to use error interrupts to monitor }
00925 \textcolor{comment}{               the error events and handle them in the interrupt IRQ handler.}
00926 \textcolor{comment}{         }
00927 \textcolor{comment}{     @note }
00928 \textcolor{comment}{         For error management, it is advised to use the following functions:}
00929 \textcolor{comment}{           - I2C\_ITConfig() to configure and enable the error interrupts (I2C\_IT\_ERR).}
00930 \textcolor{comment}{           - I2Cx\_ER\_IRQHandler() which is called when the error interrupt occurs.}
00931 \textcolor{comment}{             Where x is the peripheral instance (I2C1, I2C2 ...)}
00932 \textcolor{comment}{           - I2C\_GetFlagStatus() or I2C\_GetITStatus()  to be called into the }
00933 \textcolor{comment}{             I2Cx\_ER\_IRQHandler() function in order to determine which error occurred.}
00934 \textcolor{comment}{           - I2C\_ClearFlag() or I2C\_ClearITPendingBit() and/or I2C\_SoftwareResetCmd() }
00935 \textcolor{comment}{             and/or I2C\_GenerateStop() in order to clear the error flag and source }
00936 \textcolor{comment}{             and return to correct  communication status.}
00937 \textcolor{comment}{             }
00938 \textcolor{comment}{ }
00939 \textcolor{comment}{     2. Advanced state monitoring (Using the function I2C\_GetLastEvent())}
00940 \textcolor{comment}{     -------------------------------------------------------------------- }
00941 \textcolor{comment}{        Using the function I2C\_GetLastEvent() which returns the image of both status }
00942 \textcolor{comment}{        registers in a single word (uint32\_t) (Status Register 2 value is shifted left }
00943 \textcolor{comment}{        by 16 bits and concatenated to Status Register 1).}
00944 \textcolor{comment}{}
00945 \textcolor{comment}{          - When to use}
00946 \textcolor{comment}{             - This function is suitable for the same applications above but it }
00947 \textcolor{comment}{               allows to overcome the mentioned limitation of I2C\_GetFlagStatus() }
00948 \textcolor{comment}{               function.}
00949 \textcolor{comment}{             - The returned value could be compared to events already defined in }
00950 \textcolor{comment}{               the library (stm32f4xx\_i2c.h) or to custom values defined by user.}
00951 \textcolor{comment}{               This function is suitable when multiple flags are monitored at the }
00952 \textcolor{comment}{               same time.}
00953 \textcolor{comment}{             - At the opposite of I2C\_CheckEvent() function, this function allows }
00954 \textcolor{comment}{               user to choose when an event is accepted (when all events flags are }
00955 \textcolor{comment}{               set and no other flags are set or just when the needed flags are set }
00956 \textcolor{comment}{               like I2C\_CheckEvent() function.}
00957 \textcolor{comment}{}
00958 \textcolor{comment}{          - Limitations}
00959 \textcolor{comment}{             - User may need to define his own events.}
00960 \textcolor{comment}{             - Same remark concerning the error management is applicable for this }
00961 \textcolor{comment}{               function if user decides to check only regular communication flags }
00962 \textcolor{comment}{               (and ignores error flags).}
00963 \textcolor{comment}{      }
00964 \textcolor{comment}{ }
00965 \textcolor{comment}{     3. Flag-based state monitoring (Using the function I2C\_GetFlagStatus())}
00966 \textcolor{comment}{     -----------------------------------------------------------------------}
00967 \textcolor{comment}{     }
00968 \textcolor{comment}{      Using the function I2C\_GetFlagStatus() which simply returns the status of }
00969 \textcolor{comment}{      one single flag (ie. I2C\_FLAG\_RXNE ...). }
00970 \textcolor{comment}{}
00971 \textcolor{comment}{          - When to use}
00972 \textcolor{comment}{             - This function could be used for specific applications or in debug }
00973 \textcolor{comment}{               phase.}
00974 \textcolor{comment}{             - It is suitable when only one flag checking is needed (most I2C }
00975 \textcolor{comment}{               events are monitored through multiple flags).}
00976 \textcolor{comment}{          - Limitations: }
00977 \textcolor{comment}{             - When calling this function, the Status register is accessed. }
00978 \textcolor{comment}{               Some flags are cleared when the status register is accessed. }
00979 \textcolor{comment}{               So checking the status of one Flag, may clear other ones.}
00980 \textcolor{comment}{             - Function may need to be called twice or more in order to monitor }
00981 \textcolor{comment}{               one single event.}
00982 \textcolor{comment}{ }
00983 \textcolor{comment}{   For detailed description of Events, please refer to section I2C\_Events in }
00984 \textcolor{comment}{   stm32f4xx\_i2c.h file.}
00985 \textcolor{comment}{       }
00986 \textcolor{comment}{@endverbatim}
00987 \textcolor{comment}{  * @\{}
00988 \textcolor{comment}{  */}
00989 
00990 \textcolor{comment}{/**}
00991 \textcolor{comment}{  * @brief  Reads the specified I2C register and returns its value.}
00992 \textcolor{comment}{  * @param  I2C\_Register: specifies the register to read.}
00993 \textcolor{comment}{  *          This parameter can be one of the following values:}
00994 \textcolor{comment}{  *            @arg I2C\_Register\_CR1:  CR1 register.}
00995 \textcolor{comment}{  *            @arg I2C\_Register\_CR2:   CR2 register.}
00996 \textcolor{comment}{  *            @arg I2C\_Register\_OAR1:  OAR1 register.}
00997 \textcolor{comment}{  *            @arg I2C\_Register\_OAR2:  OAR2 register.}
00998 \textcolor{comment}{  *            @arg I2C\_Register\_DR:    DR register.}
00999 \textcolor{comment}{  *            @arg I2C\_Register\_SR1:   SR1 register.}
01000 \textcolor{comment}{  *            @arg I2C\_Register\_SR2:   SR2 register.}
01001 \textcolor{comment}{  *            @arg I2C\_Register\_CCR:   CCR register.}
01002 \textcolor{comment}{  *            @arg I2C\_Register\_TRISE: TRISE register.}
01003 \textcolor{comment}{  * @retval The value of the read register.}
01004 \textcolor{comment}{  */}
01005 uint16\_t I2C_ReadRegister(I2C\_TypeDef* I2Cx, uint8\_t I2C\_Register)
01006 \{
01007   \_\_IO uint32\_t tmp = 0;
01008 
01009   \textcolor{comment}{/* Check the parameters */}
01010   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01011   assert_param(IS\_I2C\_REGISTER(I2C\_Register));
01012 
01013   tmp = (uint32\_t) I2Cx;
01014   tmp += I2C\_Register;
01015 
01016   \textcolor{comment}{/* Return the selected register value */}
01017   \textcolor{keywordflow}{return} (*(\_\_IO uint16\_t *) tmp);
01018 \}
01019 
01020 \textcolor{comment}{/**}
01021 \textcolor{comment}{  * @brief  Enables or disables the specified I2C interrupts.}
01022 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01023 \textcolor{comment}{  * @param  I2C\_IT: specifies the I2C interrupts sources to be enabled or disabled. }
01024 \textcolor{comment}{  *          This parameter can be any combination of the following values:}
01025 \textcolor{comment}{  *            @arg I2C\_IT\_BUF: Buffer interrupt mask}
01026 \textcolor{comment}{  *            @arg I2C\_IT\_EVT: Event interrupt mask}
01027 \textcolor{comment}{  *            @arg I2C\_IT\_ERR: Error interrupt mask}
01028 \textcolor{comment}{  * @param  NewState: new state of the specified I2C interrupts.}
01029 \textcolor{comment}{  *          This parameter can be: ENABLE or DISABLE.}
01030 \textcolor{comment}{  * @retval None}
01031 \textcolor{comment}{  */}
01032 \textcolor{keywordtype}{void} I2C_ITConfig(I2C\_TypeDef* I2Cx, uint16\_t I2C\_IT, FunctionalState NewState)
01033 \{
01034   \textcolor{comment}{/* Check the parameters */}
01035   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01036   assert_param(IS\_FUNCTIONAL\_STATE(NewState));
01037   assert_param(IS\_I2C\_CONFIG\_IT(I2C\_IT));
01038 
01039   \textcolor{keywordflow}{if} (NewState != DISABLE)
01040   \{
01041     \textcolor{comment}{/* Enable the selected I2C interrupts */}
01042     I2Cx->CR2 |= I2C\_IT;
01043   \}
01044   \textcolor{keywordflow}{else}
01045   \{
01046     \textcolor{comment}{/* Disable the selected I2C interrupts */}
01047     I2Cx->CR2 &= (uint16\_t)~I2C\_IT;
01048   \}
01049 \}
01050 
01051 \textcolor{comment}{/*}
01052 \textcolor{comment}{ ===============================================================================}
01053 \textcolor{comment}{                          1. Basic state monitoring                    }
01054 \textcolor{comment}{ ===============================================================================  }
01055 \textcolor{comment}{ */}
01056 
01057 \textcolor{comment}{/**}
01058 \textcolor{comment}{  * @brief  Checks whether the last I2Cx Event is equal to the one passed}
01059 \textcolor{comment}{  *         as parameter.}
01060 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01061 \textcolor{comment}{  * @param  I2C\_EVENT: specifies the event to be checked. }
01062 \textcolor{comment}{  *          This parameter can be one of the following values:}
01063 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_TRANSMITTER\_ADDRESS\_MATCHED: EV1}
01064 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_RECEIVER\_ADDRESS\_MATCHED: EV1}
01065 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_TRANSMITTER\_SECONDADDRESS\_MATCHED: EV1}
01066 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_RECEIVER\_SECONDADDRESS\_MATCHED: EV1}
01067 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_GENERALCALLADDRESS\_MATCHED: EV1}
01068 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_BYTE\_RECEIVED: EV2}
01069 \textcolor{comment}{  *            @arg (I2C\_EVENT\_SLAVE\_BYTE\_RECEIVED | I2C\_FLAG\_DUALF): EV2}
01070 \textcolor{comment}{  *            @arg (I2C\_EVENT\_SLAVE\_BYTE\_RECEIVED | I2C\_FLAG\_GENCALL): EV2}
01071 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_BYTE\_TRANSMITTED: EV3}
01072 \textcolor{comment}{  *            @arg (I2C\_EVENT\_SLAVE\_BYTE\_TRANSMITTED | I2C\_FLAG\_DUALF): EV3}
01073 \textcolor{comment}{  *            @arg (I2C\_EVENT\_SLAVE\_BYTE\_TRANSMITTED | I2C\_FLAG\_GENCALL): EV3}
01074 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_ACK\_FAILURE: EV3\_2}
01075 \textcolor{comment}{  *            @arg I2C\_EVENT\_SLAVE\_STOP\_DETECTED: EV4}
01076 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_MODE\_SELECT: EV5}
01077 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_TRANSMITTER\_MODE\_SELECTED: EV6     }
01078 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_RECEIVER\_MODE\_SELECTED: EV6}
01079 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_BYTE\_RECEIVED: EV7}
01080 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_BYTE\_TRANSMITTING: EV8}
01081 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_BYTE\_TRANSMITTED: EV8\_2}
01082 \textcolor{comment}{  *            @arg I2C\_EVENT\_MASTER\_MODE\_ADDRESS10: EV9}
01083 \textcolor{comment}{  *     }
01084 \textcolor{comment}{  * @note   For detailed description of Events, please refer to section I2C\_Events}
01085 \textcolor{comment}{  *         in stm32f4xx\_i2c.h file.}
01086 \textcolor{comment}{  *    }
01087 \textcolor{comment}{  * @retval An ErrorStatus enumeration value:}
01088 \textcolor{comment}{  *           - SUCCESS: Last event is equal to the I2C\_EVENT}
01089 \textcolor{comment}{  *           - ERROR: Last event is different from the I2C\_EVENT}
01090 \textcolor{comment}{  */}
01091 ErrorStatus I2C_CheckEvent(I2C\_TypeDef* I2Cx, uint32\_t I2C\_EVENT)
01092 \{
01093   uint32\_t lastevent = 0;
01094   uint32\_t flag1 = 0, flag2 = 0;
01095   ErrorStatus status = ERROR;
01096 
01097   \textcolor{comment}{/* Check the parameters */}
01098   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01099   assert_param(IS\_I2C\_EVENT(I2C\_EVENT));
01100 
01101   \textcolor{comment}{/* Read the I2Cx status register */}
01102   flag1 = I2Cx->SR1;
01103   flag2 = I2Cx->SR2;
01104   flag2 = flag2 << 16;
01105 
01106   \textcolor{comment}{/* Get the last event value from I2C status register */}
01107   lastevent = (flag1 | flag2) & FLAG_MASK;
01108 
01109   \textcolor{comment}{/* Check whether the last event contains the I2C\_EVENT */}
01110   \textcolor{keywordflow}{if} ((lastevent & I2C\_EVENT) == I2C\_EVENT)
01111   \{
01112     \textcolor{comment}{/* SUCCESS: last event is equal to I2C\_EVENT */}
01113     status = SUCCESS;
01114   \}
01115   \textcolor{keywordflow}{else}
01116   \{
01117     \textcolor{comment}{/* ERROR: last event is different from I2C\_EVENT */}
01118     status = ERROR;
01119   \}
01120   \textcolor{comment}{/* Return status */}
01121   \textcolor{keywordflow}{return} status;
01122 \}
01123 
01124 \textcolor{comment}{/*}
01125 \textcolor{comment}{ ===============================================================================}
01126 \textcolor{comment}{                          2. Advanced state monitoring                   }
01127 \textcolor{comment}{ ===============================================================================  }
01128 \textcolor{comment}{ */}
01129 
01130 \textcolor{comment}{/**}
01131 \textcolor{comment}{  * @brief  Returns the last I2Cx Event.}
01132 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01133 \textcolor{comment}{  *     }
01134 \textcolor{comment}{  * @note   For detailed description of Events, please refer to section I2C\_Events}
01135 \textcolor{comment}{  *         in stm32f4xx\_i2c.h file.}
01136 \textcolor{comment}{  *    }
01137 \textcolor{comment}{  * @retval The last event}
01138 \textcolor{comment}{  */}
01139 uint32\_t I2C_GetLastEvent(I2C\_TypeDef* I2Cx)
01140 \{
01141   uint32\_t lastevent = 0;
01142   uint32\_t flag1 = 0, flag2 = 0;
01143 
01144   \textcolor{comment}{/* Check the parameters */}
01145   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01146 
01147   \textcolor{comment}{/* Read the I2Cx status register */}
01148   flag1 = I2Cx->SR1;
01149   flag2 = I2Cx->SR2;
01150   flag2 = flag2 << 16;
01151 
01152   \textcolor{comment}{/* Get the last event value from I2C status register */}
01153   lastevent = (flag1 | flag2) & FLAG_MASK;
01154 
01155   \textcolor{comment}{/* Return status */}
01156   \textcolor{keywordflow}{return} lastevent;
01157 \}
01158 
01159 \textcolor{comment}{/*}
01160 \textcolor{comment}{ ===============================================================================}
01161 \textcolor{comment}{                          3. Flag-based state monitoring                   }
01162 \textcolor{comment}{ ===============================================================================  }
01163 \textcolor{comment}{ */}
01164 
01165 \textcolor{comment}{/**}
01166 \textcolor{comment}{  * @brief  Checks whether the specified I2C flag is set or not.}
01167 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01168 \textcolor{comment}{  * @param  I2C\_FLAG: specifies the flag to check. }
01169 \textcolor{comment}{  *          This parameter can be one of the following values:}
01170 \textcolor{comment}{  *            @arg I2C\_FLAG\_DUALF: Dual flag (Slave mode)}
01171 \textcolor{comment}{  *            @arg I2C\_FLAG\_SMBHOST: SMBus host header (Slave mode)}
01172 \textcolor{comment}{  *            @arg I2C\_FLAG\_SMBDEFAULT: SMBus default header (Slave mode)}
01173 \textcolor{comment}{  *            @arg I2C\_FLAG\_GENCALL: General call header flag (Slave mode)}
01174 \textcolor{comment}{  *            @arg I2C\_FLAG\_TRA: Transmitter/Receiver flag}
01175 \textcolor{comment}{  *            @arg I2C\_FLAG\_BUSY: Bus busy flag}
01176 \textcolor{comment}{  *            @arg I2C\_FLAG\_MSL: Master/Slave flag}
01177 \textcolor{comment}{  *            @arg I2C\_FLAG\_SMBALERT: SMBus Alert flag}
01178 \textcolor{comment}{  *            @arg I2C\_FLAG\_TIMEOUT: Timeout or Tlow error flag}
01179 \textcolor{comment}{  *            @arg I2C\_FLAG\_PECERR: PEC error in reception flag}
01180 \textcolor{comment}{  *            @arg I2C\_FLAG\_OVR: Overrun/Underrun flag (Slave mode)}
01181 \textcolor{comment}{  *            @arg I2C\_FLAG\_AF: Acknowledge failure flag}
01182 \textcolor{comment}{  *            @arg I2C\_FLAG\_ARLO: Arbitration lost flag (Master mode)}
01183 \textcolor{comment}{  *            @arg I2C\_FLAG\_BERR: Bus error flag}
01184 \textcolor{comment}{  *            @arg I2C\_FLAG\_TXE: Data register empty flag (Transmitter)}
01185 \textcolor{comment}{  *            @arg I2C\_FLAG\_RXNE: Data register not empty (Receiver) flag}
01186 \textcolor{comment}{  *            @arg I2C\_FLAG\_STOPF: Stop detection flag (Slave mode)}
01187 \textcolor{comment}{  *            @arg I2C\_FLAG\_ADD10: 10-bit header sent flag (Master mode)}
01188 \textcolor{comment}{  *            @arg I2C\_FLAG\_BTF: Byte transfer finished flag}
01189 \textcolor{comment}{  *            @arg I2C\_FLAG\_ADDR: Address sent flag (Master mode) "ADSL"}
01190 \textcolor{comment}{  *                                Address matched flag (Slave mode)"ENDAD"}
01191 \textcolor{comment}{  *            @arg I2C\_FLAG\_SB: Start bit flag (Master mode)}
01192 \textcolor{comment}{  * @retval The new state of I2C\_FLAG (SET or RESET).}
01193 \textcolor{comment}{  */}
01194 FlagStatus I2C_GetFlagStatus(I2C\_TypeDef* I2Cx, uint32\_t I2C\_FLAG)
01195 \{
01196   FlagStatus bitstatus = RESET;
01197   \_\_IO uint32\_t i2creg = 0, i2cxbase = 0;
01198 
01199   \textcolor{comment}{/* Check the parameters */}
01200   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01201   assert_param(IS\_I2C\_GET\_FLAG(I2C\_FLAG));
01202 
01203   \textcolor{comment}{/* Get the I2Cx peripheral base address */}
01204   i2cxbase = (uint32\_t)I2Cx;
01205 
01206   \textcolor{comment}{/* Read flag register index */}
01207   i2creg = I2C\_FLAG >> 28;
01208 
01209   \textcolor{comment}{/* Get bit[23:0] of the flag */}
01210   I2C\_FLAG &= FLAG_MASK;
01211 
01212   \textcolor{keywordflow}{if}(i2creg != 0)
01213   \{
01214     \textcolor{comment}{/* Get the I2Cx SR1 register address */}
01215     i2cxbase += 0x14;
01216   \}
01217   \textcolor{keywordflow}{else}
01218   \{
01219     \textcolor{comment}{/* Flag in I2Cx SR2 Register */}
01220     I2C\_FLAG = (uint32\_t)(I2C\_FLAG >> 16);
01221     \textcolor{comment}{/* Get the I2Cx SR2 register address */}
01222     i2cxbase += 0x18;
01223   \}
01224 
01225   \textcolor{keywordflow}{if}(((*(\_\_IO uint32\_t *)i2cxbase) & I2C\_FLAG) != (uint32\_t)RESET)
01226   \{
01227     \textcolor{comment}{/* I2C\_FLAG is set */}
01228     bitstatus = SET;
01229   \}
01230   \textcolor{keywordflow}{else}
01231   \{
01232     \textcolor{comment}{/* I2C\_FLAG is reset */}
01233     bitstatus = RESET;
01234   \}
01235 
01236   \textcolor{comment}{/* Return the I2C\_FLAG status */}
01237   \textcolor{keywordflow}{return}  bitstatus;
01238 \}
01239 
01240 \textcolor{comment}{/**}
01241 \textcolor{comment}{  * @brief  Clears the I2Cx's pending flags.}
01242 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01243 \textcolor{comment}{  * @param  I2C\_FLAG: specifies the flag to clear. }
01244 \textcolor{comment}{  *          This parameter can be any combination of the following values:}
01245 \textcolor{comment}{  *            @arg I2C\_FLAG\_SMBALERT: SMBus Alert flag}
01246 \textcolor{comment}{  *            @arg I2C\_FLAG\_TIMEOUT: Timeout or Tlow error flag}
01247 \textcolor{comment}{  *            @arg I2C\_FLAG\_PECERR: PEC error in reception flag}
01248 \textcolor{comment}{  *            @arg I2C\_FLAG\_OVR: Overrun/Underrun flag (Slave mode)}
01249 \textcolor{comment}{  *            @arg I2C\_FLAG\_AF: Acknowledge failure flag}
01250 \textcolor{comment}{  *            @arg I2C\_FLAG\_ARLO: Arbitration lost flag (Master mode)}
01251 \textcolor{comment}{  *            @arg I2C\_FLAG\_BERR: Bus error flag}
01252 \textcolor{comment}{  *   }
01253 \textcolor{comment}{  * @note   STOPF (STOP detection) is cleared by software sequence: a read operation }
01254 \textcolor{comment}{  *          to I2C\_SR1 register (I2C\_GetFlagStatus()) followed by a write operation }
01255 \textcolor{comment}{  *          to I2C\_CR1 register (I2C\_Cmd() to re-enable the I2C peripheral).}
01256 \textcolor{comment}{  * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read }
01257 \textcolor{comment}{  *          operation to I2C\_SR1 (I2C\_GetFlagStatus()) followed by writing the }
01258 \textcolor{comment}{  *          second byte of the address in DR register.}
01259 \textcolor{comment}{  * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read }
01260 \textcolor{comment}{  *          operation to I2C\_SR1 register (I2C\_GetFlagStatus()) followed by a }
01261 \textcolor{comment}{  *          read/write to I2C\_DR register (I2C\_SendData()).}
01262 \textcolor{comment}{  * @note   ADDR (Address sent) is cleared by software sequence: a read operation to }
01263 \textcolor{comment}{  *          I2C\_SR1 register (I2C\_GetFlagStatus()) followed by a read operation to }
01264 \textcolor{comment}{  *          I2C\_SR2 register ((void)(I2Cx->SR2)).}
01265 \textcolor{comment}{  * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C\_SR1}
01266 \textcolor{comment}{  *          register (I2C\_GetFlagStatus()) followed by a write operation to I2C\_DR}
01267 \textcolor{comment}{  *          register (I2C\_SendData()).}
01268 \textcolor{comment}{  *  }
01269 \textcolor{comment}{  * @retval None}
01270 \textcolor{comment}{  */}
01271 \textcolor{keywordtype}{void} I2C_ClearFlag(I2C\_TypeDef* I2Cx, uint32\_t I2C\_FLAG)
01272 \{
01273   uint32\_t flagpos = 0;
01274   \textcolor{comment}{/* Check the parameters */}
01275   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01276   assert_param(IS\_I2C\_CLEAR\_FLAG(I2C\_FLAG));
01277   \textcolor{comment}{/* Get the I2C flag position */}
01278   flagpos = I2C\_FLAG & FLAG_MASK;
01279   \textcolor{comment}{/* Clear the selected I2C flag */}
01280   I2Cx->SR1 = (uint16\_t)~flagpos;
01281 \}
01282 
01283 \textcolor{comment}{/**}
01284 \textcolor{comment}{  * @brief  Checks whether the specified I2C interrupt has occurred or not.}
01285 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01286 \textcolor{comment}{  * @param  I2C\_IT: specifies the interrupt source to check. }
01287 \textcolor{comment}{  *          This parameter can be one of the following values:}
01288 \textcolor{comment}{  *            @arg I2C\_IT\_SMBALERT: SMBus Alert flag}
01289 \textcolor{comment}{  *            @arg I2C\_IT\_TIMEOUT: Timeout or Tlow error flag}
01290 \textcolor{comment}{  *            @arg I2C\_IT\_PECERR: PEC error in reception flag}
01291 \textcolor{comment}{  *            @arg I2C\_IT\_OVR: Overrun/Underrun flag (Slave mode)}
01292 \textcolor{comment}{  *            @arg I2C\_IT\_AF: Acknowledge failure flag}
01293 \textcolor{comment}{  *            @arg I2C\_IT\_ARLO: Arbitration lost flag (Master mode)}
01294 \textcolor{comment}{  *            @arg I2C\_IT\_BERR: Bus error flag}
01295 \textcolor{comment}{  *            @arg I2C\_IT\_TXE: Data register empty flag (Transmitter)}
01296 \textcolor{comment}{  *            @arg I2C\_IT\_RXNE: Data register not empty (Receiver) flag}
01297 \textcolor{comment}{  *            @arg I2C\_IT\_STOPF: Stop detection flag (Slave mode)}
01298 \textcolor{comment}{  *            @arg I2C\_IT\_ADD10: 10-bit header sent flag (Master mode)}
01299 \textcolor{comment}{  *            @arg I2C\_IT\_BTF: Byte transfer finished flag}
01300 \textcolor{comment}{  *            @arg I2C\_IT\_ADDR: Address sent flag (Master mode) "ADSL"}
01301 \textcolor{comment}{  *                              Address matched flag (Slave mode)"ENDAD"}
01302 \textcolor{comment}{  *            @arg I2C\_IT\_SB: Start bit flag (Master mode)}
01303 \textcolor{comment}{  * @retval The new state of I2C\_IT (SET or RESET).}
01304 \textcolor{comment}{  */}
01305 ITStatus I2C_GetITStatus(I2C\_TypeDef* I2Cx, uint32\_t I2C\_IT)
01306 \{
01307   ITStatus bitstatus = RESET;
01308   uint32\_t enablestatus = 0;
01309 
01310   \textcolor{comment}{/* Check the parameters */}
01311   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01312   assert_param(IS\_I2C\_GET\_IT(I2C\_IT));
01313 
01314   \textcolor{comment}{/* Check if the interrupt source is enabled or not */}
01315   enablestatus = (uint32\_t)(((I2C\_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
01316 
01317   \textcolor{comment}{/* Get bit[23:0] of the flag */}
01318   I2C\_IT &= FLAG_MASK;
01319 
01320   \textcolor{comment}{/* Check the status of the specified I2C flag */}
01321   \textcolor{keywordflow}{if} (((I2Cx->SR1 & I2C\_IT) != (uint32\_t)RESET) && enablestatus)
01322   \{
01323     \textcolor{comment}{/* I2C\_IT is set */}
01324     bitstatus = SET;
01325   \}
01326   \textcolor{keywordflow}{else}
01327   \{
01328     \textcolor{comment}{/* I2C\_IT is reset */}
01329     bitstatus = RESET;
01330   \}
01331   \textcolor{comment}{/* Return the I2C\_IT status */}
01332   \textcolor{keywordflow}{return}  bitstatus;
01333 \}
01334 
01335 \textcolor{comment}{/**}
01336 \textcolor{comment}{  * @brief  Clears the I2Cx's interrupt pending bits.}
01337 \textcolor{comment}{  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.}
01338 \textcolor{comment}{  * @param  I2C\_IT: specifies the interrupt pending bit to clear. }
01339 \textcolor{comment}{  *          This parameter can be any combination of the following values:}
01340 \textcolor{comment}{  *            @arg I2C\_IT\_SMBALERT: SMBus Alert interrupt}
01341 \textcolor{comment}{  *            @arg I2C\_IT\_TIMEOUT: Timeout or Tlow error interrupt}
01342 \textcolor{comment}{  *            @arg I2C\_IT\_PECERR: PEC error in reception  interrupt}
01343 \textcolor{comment}{  *            @arg I2C\_IT\_OVR: Overrun/Underrun interrupt (Slave mode)}
01344 \textcolor{comment}{  *            @arg I2C\_IT\_AF: Acknowledge failure interrupt}
01345 \textcolor{comment}{  *            @arg I2C\_IT\_ARLO: Arbitration lost interrupt (Master mode)}
01346 \textcolor{comment}{  *            @arg I2C\_IT\_BERR: Bus error interrupt}
01347 \textcolor{comment}{  * }
01348 \textcolor{comment}{  * @note   STOPF (STOP detection) is cleared by software sequence: a read operation }
01349 \textcolor{comment}{  *          to I2C\_SR1 register (I2C\_GetITStatus()) followed by a write operation to }
01350 \textcolor{comment}{  *          I2C\_CR1 register (I2C\_Cmd() to re-enable the I2C peripheral).}
01351 \textcolor{comment}{  * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read }
01352 \textcolor{comment}{  *          operation to I2C\_SR1 (I2C\_GetITStatus()) followed by writing the second }
01353 \textcolor{comment}{  *          byte of the address in I2C\_DR register.}
01354 \textcolor{comment}{  * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read }
01355 \textcolor{comment}{  *          operation to I2C\_SR1 register (I2C\_GetITStatus()) followed by a }
01356 \textcolor{comment}{  *          read/write to I2C\_DR register (I2C\_SendData()).}
01357 \textcolor{comment}{  * @note   ADDR (Address sent) is cleared by software sequence: a read operation to }
01358 \textcolor{comment}{  *          I2C\_SR1 register (I2C\_GetITStatus()) followed by a read operation to }
01359 \textcolor{comment}{  *          I2C\_SR2 register ((void)(I2Cx->SR2)).}
01360 \textcolor{comment}{  * @note   SB (Start Bit) is cleared by software sequence: a read operation to }
01361 \textcolor{comment}{  *          I2C\_SR1 register (I2C\_GetITStatus()) followed by a write operation to }
01362 \textcolor{comment}{  *          I2C\_DR register (I2C\_SendData()).}
01363 \textcolor{comment}{  * @retval None}
01364 \textcolor{comment}{  */}
01365 \textcolor{keywordtype}{void} I2C_ClearITPendingBit(I2C\_TypeDef* I2Cx, uint32\_t I2C\_IT)
01366 \{
01367   uint32\_t flagpos = 0;
01368   \textcolor{comment}{/* Check the parameters */}
01369   assert_param(IS\_I2C\_ALL\_PERIPH(I2Cx));
01370   assert_param(IS\_I2C\_CLEAR\_IT(I2C\_IT));
01371 
01372   \textcolor{comment}{/* Get the I2C flag position */}
01373   flagpos = I2C\_IT & FLAG_MASK;
01374 
01375   \textcolor{comment}{/* Clear the selected I2C flag */}
01376   I2Cx->SR1 = (uint16\_t)~flagpos;
01377 \}
01378 
01379 \textcolor{comment}{/**}
01380 \textcolor{comment}{  * @\}}
01381 \textcolor{comment}{  */}
01382 
01383 \textcolor{comment}{/**}
01384 \textcolor{comment}{  * @\}}
01385 \textcolor{comment}{  */}
01386 
01387 \textcolor{comment}{/**}
01388 \textcolor{comment}{  * @\}}
01389 \textcolor{comment}{  */}
01390 
01391 \textcolor{comment}{/**}
01392 \textcolor{comment}{  * @\}}
01393 \textcolor{comment}{  */}
01394 
01395 \textcolor{comment}{/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/}
\end{DoxyCode}
